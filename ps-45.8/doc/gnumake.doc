Date: Fri, 27 Apr 90 06:10:18 PDT
From: Terence_Donahue
To: tdonahue

Info file make-info, produced by Makeinfo, -*- Text -*- from input
file make.texinfo.

This file documents the GNU Make utility.

Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled ``GNU General Public License'' is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translations of the section
entitled ``GNU General Public License'' must be approved for accuracy
by the Foundation.



File: make-info,  Node: Top,  Next: Overview,  Up: (dir)

The GNU `make' utility determines automatically which pieces of a
large program need to be recompiled, and issues the commands to
recompile them.  This manual describes it and contains the following
chapters:

* Menu:

* Overview::    Introducing `make'.
* Copying::     Copying conditions for GNU `make'.
* Bugs::        If you have problems, or think you've found a bug.
* Simple::      A simple example explained.
* Makefiles::   The data base contains rules and variable definitions.
* Rules::       A rule says how and when to remake one file.
* Commands::    A rule contains shell commands that say how to remake.
* Variables::   A variable holds a text string for substitution into rules.
* Conditionals::Makefiles that do one thing or another depending on
                 variable values.
* Functions::   Functions can do text-processing within `make'.

* Running::     How to run `make'; how you can adjust the way
                 `make' uses the makefile.

* Implicit::    Implicit rules take over if the makefile doesn't say
                 how a file is to be remade.
* Archives::    How to use `make' to update archive files.

* Features::    GNU `make''s advanced features and how GNU `make'
                 relates to other versions of `make'.
* Missing::     Features of other `make's not supported
                 by GNU `make'.

* Concept Index::Index of cross-references to where concepts are discussed.
* Name Index::  Index of cross-references for names of `make''s
                 variables, functions, special targets and directives.

 

File: make-info,  Node: Overview,  Next: Copying,  Prev: Top,  Up: Top

Overview of `make'
******************

The purpose of the `make' utility is to determine automatically which
pieces of a large program need to be recompiled, and issue the
commands to recompile them.  This manual describes the GNU
implementation of `make', which was implemented by Richard Stallman
and Roland McGrath.

Our examples show C programs, since they are most common, but you can
use `make' with any programming language whose compiler can be run
with a shell command.  In fact, `make' is not limited to programs. 
You can use it to describe any task where some files must be updated
automatically from others whenever the others change.

To prepare to use `make', you must write a file called the "makefile"
that describes the relationships among files in your program, and the
states the commands for updating each file.  In a program, typically
the executable file is updated from object files, which are in turn
made by compiling source files.

Once a suitable makefile exists, each time you change some source
files, this simple shell command:

     make

suffices to perform all necessary recompilations.  The `make' program
uses the makefile data base and the last-modification times of the
files to decide which of the files need to be updated.  For each of
those files, it issues the commands recorded in the data base.



File: make-info,  Node: Copying,  Next: Bugs,  Prev: Overview,  Up: Top

GNU GENERAL PUBLIC LICENSE
**************************

                        Version 1, February 1989

     Copyright (C) 1989 Free Software Foundation, Inc.
     675 Mass Ave, Cambridge, MA 02139, USA
     
     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

 Preamble
=========

  The license agreements of most software companies try to keep users
at the mercy of those companies.  By contrast, our General Public
License is intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users. 
The General Public License applies to the Free Software Foundation's
software and to any other program whose authors commit to using it. 
You can use it for your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Specifically, the General Public License is designed to make
sure that you have the freedom to give away or sell copies of free
software, that you receive source code or can get it if you want it,
that you can change the software or use pieces of it in new free
programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if
you distribute copies of the software, or if you modify it.

  For example, if you distribute copies of a such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.

  We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to
copy, distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on,
we want its recipients to know that what they have is not the
original, so that any problems introduced by others will not reflect
on the original authors' reputations.

  The precise terms and conditions for copying, distribution and
modification follow.

                          TERMS AND CONDITIONS

  1. This License Agreement applies to any program or other work
     which contains a notice placed by the copyright holder saying it
     may be distributed under the terms of this General Public
     License.  The ``Program'', below, refers to any such program or
     work, and a ``work based on the Program'' means either the
     Program or any work containing the Program or a portion of it,
     either verbatim or with modifications.  Each licensee is
     addressed as ``you''.

  2. You may copy and distribute verbatim copies of the Program's
     source code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an
     appropriate copyright notice and disclaimer of warranty; keep
     intact all the notices that refer to this General Public License
     and to the absence of any warranty; and give any other
     recipients of the Program a copy of this General Public License
     along with the Program.  You may charge a fee for the physical
     act of transferring a copy.

  3. You may modify your copy or copies of the Program or any portion
     of it, and copy and distribute such modifications under the
     terms of Paragraph 1 above, provided that you also do the
     following:

        * cause the modified files to carry prominent notices stating
          that you changed the files and the date of any change; and

        * cause the whole of any work that you distribute or publish,
          that in whole or in part contains the Program or any part
          thereof, either with or without modifications, to be
          licensed at no charge to all third parties under the terms
          of this General Public License (except that you may choose
          to grant warranty protection to some or all third parties,
          at your option).

        * If the modified program normally reads commands
          interactively when run, you must cause it, when started
          running for such interactive use in the simplest and most
          usual way, to print or display an announcement including an
          appropriate copyright notice and a notice that there is no
          warranty (or else, saying that you provide a warranty) and
          that users may redistribute the program under these
          conditions, and telling the user how to view a copy of this
          General Public License.

        * You may charge a fee for the physical act of transferring a
          copy, and you may at your option offer warranty protection
          in exchange for a fee.

     Mere aggregation of another independent work with the Program
     (or its derivative) on a volume of a storage or distribution
     medium does not bring the other work under the scope of these
     terms.

  4. You may copy and distribute the Program (or a portion or
     derivative of it, under Paragraph 2) in object code or
     executable form under the terms of Paragraphs 1 and 2 above
     provided that you also do one of the following:

        * accompany it with the complete corresponding
          machine-readable source code, which must be distributed
          under the terms of Paragraphs 1 and 2 above; or,

        * accompany it with a written offer, valid for at least three
          years, to give any third party free (except for a nominal
          charge for the cost of distribution) a complete
          machine-readable copy of the corresponding source code, to
          be distributed under the terms of Paragraphs 1 and 2 above;
          or,

        * accompany it with the information you received as to where
          the corresponding source code may be obtained.  (This
          alternative is allowed only for noncommercial distribution
          and only if you received the program in object code or
          executable form alone.)

     Source code for a work means the preferred form of the work for
     making modifications to it.  For an executable file, complete
     source code means all the source code for all modules it
     contains; but, as a special exception, it need not include
     source code for modules which are standard libraries that
     accompany the operating system on which the executable file
     runs, or for standard header files or definitions files that
     accompany that operating system.

  5. You may not copy, modify, sublicense, distribute or transfer the
     Program except as expressly provided under this General Public
     License.  Any attempt otherwise to copy, modify, sublicense,
     distribute or transfer the Program is void, and will
     automatically terminate your rights to use the Program under
     this License.  However, parties who have received copies, or
     rights to use copies, from you under this General Public License
     will not have their licenses terminated so long as such parties
     remain in full compliance.

  6. By copying, distributing or modifying the Program (or any work
     based on the Program) you indicate your acceptance of this
     license to do so, and all its terms and conditions.

  7. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from
     the original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein.

  8. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version,
     but may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of the license which applies
     to it and ``any later version'', you have the option of
     following the terms and conditions either of that version or of
     any later version published by the Free Software Foundation.  If
     the Program does not specify a version number of the license,
     you may choose any version ever published by the Free Software
     Foundation.

  9. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to
     the author to ask for permission.  For software which is
     copyrighted by the Free Software Foundation, write to the Free
     Software Foundation; we sometimes make exceptions for this.  Our
     decision will be guided by the two goals of preserving the free
     status of all derivatives of our free software and of promoting
     the sharing and reuse of software generally.

                                   NO WARRANTY

 10. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM ``AS IS''
     WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE
     ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS
     WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE
     COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

 11. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS
     OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
     YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH
     ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS

Appendix: How to Apply These Terms to Your New Programs
=======================================================

  If you develop a new program, and you want it to be of the greatest
possible use to humanity, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the ``copyright'' line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) 19YY  NAME OF AUTHOR
     
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 1, or (at your option)
     any later version.
     
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

 Also add information on how to contact you by electronic and paper
mail.

If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

 The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and
`show c'; they could even be mouse-clicks or menu items--whatever
suits your program.

You should also get your employer (if you work as a programmer) or
your school, if any, to sign a ``copyright disclaimer'' for the
program, if necessary.  Here a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in the
     program `Gnomovision' (a program to direct compilers to make passes
     at assemblers) written by James Hacker.
     
     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

That's all there is to it!



File: make-info,  Node: Bugs,  Next: Simple,  Prev: Copying,  Up: Top

Problems and Bugs
*****************

If you have problems with GNU `make' or think you've found a bug,
please report it to Roland McGrath; he doesn't promise to do anything
but he might well want to fix it.

Before reporting a bug, make sure you've actually found a real bug. 
Carefully reread the documentation and see if it really says you can
do what you're trying to do.  If it's not clear whether you should be
able to do something or not, report that too; it's a bug in the
documentation!

Before reporting a bug or trying to fix it yourself, try to isolate
it to the smallest possible makefile that reproduces the problem. 
Then send us the makefile and the exact results `make' gave you. 
Also say what you expected to occur; this will help us decide whether
the problem was really in the documentation.

Once you've got a precise problem, send email to (Internet)
`bug-gnu-utils@prep.ai.mit.edu' or (UUCP)
`mit-eddie!prep.ai.mit.edu!bug-gnu-utils'.  Please include the
version number of `make' you are using.  You can get this information
with the command `make -v -f /dev/null'.

Non-bug suggestions are always welcome as well.  If you have
questions about things that are unclear in the documentation or are
just obscure features, ask Roland McGrath; he'll be happy to help you
out (but no promises).  You can send him electronic mail at Internet
address `roland@prep.ai.mit.edu' or UUCP path
`mit-eddie!prep.ai.mit.edu!roland'.



File: make-info,  Node: Simple,  Next: Makefiles,  Prev: Bugs,  Up: Top

Simple Example of `make'
************************

Suppose we have a text editor consisting of eight C source files and
three header files.  We need a makefile to tell `make' how to compile
and link the editor.  Assume that all the C files include `defs.h',
but only those defining editing commands include `commands.h' and
only low level files that change the editor buffer include `buffer.h'.

To recompile the editor, each changed C source file must be
recompiled.  If a header file has changed, to be safe each C source
file that includes the header file must be recompiled.  Each
compilation produces an object file corresponding to the source file.
Finally, if any source file has been recompiled, all the object
files, whether newly made or saved from previous compilations, must
be linked together to produce the new executable editor.

Here is a straightforward makefile that describes these criteria and
says how to compile and link when the time comes:

     edit : main.o kbd.o commands.o display.o \
            insert.o search.o files.o utils.o
             cc -o edit main.o kbd.o commands.o display.o \
                        insert.o search.o files.o utils.o
     
     main.o : main.c defs.h
             cc -c main.c
     kbd.o : kbd.c defs.h command.h
             cc -c kbd.c
     commands.o : command.c defs.h command.h
             cc -c commands.c
     display.o : display.c defs.h buffer.h
             cc -c display.c
     insert.o : insert.c defs.h buffer.h
             cc -c insert.c
     search.o : search.c defs.h buffer.h
             cc -c search.c
     files.o : files.c defs.h buffer.h command.h
             cc -c files.c
     utils.o : utils.c defs.h
             cc -c utils.c

We split each long line into two lines using a backslash-newline;
this is like using one long line, but is easier to read.

Each file that is generated by a program--that is to say, each file
except for source files--is the "target" of a "rule" (*note Rules::.).
(In this example, these are the object files such as `main.o',
`kbd.o', etc., and the executable file `edit'.)  The target appears
at the beginning of a line, followed by a colon.

After the colon come the target's "dependencies": all the files that
are used as input when the target file is updated.  A target file
needs to be recompiled or relinked if any of its dependencies
changes.  In addition, any dependencies that are themselves
automatically generated should be updated first.  In this example,
`edit' depends on each of the eight object files; the object file
`main.o' depends on the source file `main.c' and on the header file
`defs.h'.

By default, `make' starts with the first rule (not counting rules
whose target names start with `.').  This is called the "default
goal".  Therefore, we put the rule for the executable program `edit'
first.  The other rules are processed because their targets appear as
dependencies of the goal.

After each line containing a target and dependencies come one or more
lines of shell commands that say how to update the target file. 
These lines start with a tab to tell `make' that they are command
lines.  But `make' does not know anything about how the commands
work.  It is up to you to supply commands that will update the target
file properly.  All `make' does is execute the commands you have
specified when the target file needs to be updated.

How `make' Processes This Makefile
==================================

After reading the makefile, `make' begins its real work by processing
the first rule, the one for relinking `edit'; but before it can fully
process this rule, it must process the rules for the files `edit'
depends on: all the object files.  Each of these files is processed
according to its own rule.  These rules say to update the `.o' file
by compiling its source file.  The recompilation must be done if the
source file, or any of the header files named as dependencies, is
more recent than the object file, or if the object file does not exist.

Before recompiling an object file, `make' considers updating its
dependencies, the source file and header files.  This makefile does
not specify anything to be done for them--the `.c' and `.h' files are
not the targets of any rules--so nothing needs to be done.  But
automatically generated C programs, such as made by Bison or Yacc,
would be updated by their own rules at this time.

After recompiling whichever object files need it, `make' can now
decide whether to relink `edit'.  This must be done if the file
`edit' does not exist, or if any of the object files are newer than
it.  If an object file was just recompiled, it is now newer than
`edit', so `edit' will be relinked.

Thus, if we change the file `insert.c' and run `make', `make' will
compile that file to update `insert.o', and then link `edit'.  If we
change the file `command.h' and run `make', `make' will recompile the
object files `kbd.o', `commands.o' and `files.o' and then link file
`edit'.

Variables Make Makefiles Simpler
================================

In our example, we had to list all the object files twice in the rule
for `edit' (repeated here):

     edit : main.o kbd.o commands.o display.o \
                   insert.o search.o files.o utils.o
             cc -o edit main.o kbd.o commands.o display.o \
                        insert.o search.o files.o utils.o

Such duplication is error-prone; if a new object file is added to the
system, we might add it to one list and forget the other.  We can
eliminate the risk and simplify the makefile by using a "variable". 
Variables allow a text string to be defined once and substituted in
multiple places later (*note Variables::.).

It is standard practice for every makefile to have a variable named
`objects', `OBJECTS', `objs', `OBJS', `obj' or `OBJ' which is a list
of all object file names.  We would define such a variable `objects'
with a line like this in the makefile:

     objects = main.o kbd.o commands.o display.o \
                   insert.o search.o files.o utils.o

Then, each place we want to put a list of the object file names, we
can substitute the variable's value by writing `$(objects)' (*note
Variables::.).  Here is how the rule for `edit' looks as a result:

     edit : $(objects)
             cc -o edit $(objects)

Letting `make' Deduce the Commands
==================================

It is not necessary to spell out the commands for compiling the
individual C source files, because `make' can figure them out: it has
an "implicit rule" for updating a `.o' file from a correspondingly
named `.c' file using a `cc -c' command.  For example, it will use
the command `cc -c main.c -o main.o' to compile `main.c' into
`main.o'.  We can therefore omit the commands from the rules for the
object files.  *Note Implicit::.

When a `.c' file is used automatically in this way, it is also
automatically added to the list of dependencies.  We can therefore
omit the `.c' files from the dependencies, provided we omit the
commands.

Here is the entire example, with both of these changes, and a
variable `objects' as suggested above:

     objects =  main.o kbd.o commands.o display.o \
      insert.o search.o files.o utils.o
     
     edit : $(objects)
             cc -o edit $(objects)
     
     main.o : defs.h
     kbd.o : defs.h command.h
     commands.o : defs.h command.h
     display.o : defs.h buffer.h
     insert.o : defs.h buffer.h
     search.o : defs.h buffer.h
     files.o : defs.h buffer.h command.h
     utils.o : defs.h

This is how we would write the makefile in actual practice.

Another Style of Makefile
=========================

Since the rules for the object files specify only dependencies, no
commands, one can alternatively combine them by dependency instead of
by target.  Here is what it looks like:

     objects =  main.o kbd.o commands.o display.o \
      insert.o search.o files.o utils.o
     
     edit : $(objects)
             cc -o edit $(objects)
     
     $(objects) : defs.h
     kbd.o commands.o files.o : command.h
     display.o insert.o search.o files.o : buffer.h

Here `defs.h' is given as a dependency of all the object files;
`commands.h' and `buffer.h' are dependencies of the specific object
files listed for them.

Whether this is better is a matter of taste: it is more compact, but
some people dislike it because they find it clearer to put all the
information about each target in one place.

Rules for Cleaning the Directory
================================

Compiling a program isn't the only thing you might want to write
rules for.  Makefiles commonly tell how to do a few other things
besides compiling the program: for example, how to delete all the
object files and executables so that the directory is ``clean''. 
Here is how we would write a `make' rule for cleaning our example
editor:

     clean:
             rm edit $(objects)

This rule would be added at the end of the makefile, because we don't
want it to run by default!  We want the rule for `edit', which
recompiles the editor, to remain the default goal.

Since `clean' is not a dependency of `edit', this rule won't run at
all if we give the command `make' with no arguments.  In order to
make the rule run, we have to type `make clean'.



File: make-info,  Node: Makefiles,  Next: Rules,  Prev: Simple,  Up: Top

Writing Makefiles
*****************

The information that tells `make' how to recompile a system comes
from reading a data base called the "makefile".

* Menu:

* Contents: Makefile Contents.   Overview of what you put in a makefile.
* Names: Makefile Names.         Where `make' finds the makefile.
* Include::                      How one makefile can use another makefile.
* MAKEFILES Variable::           The environment can specify extra makefiles.
* Remaking Makefiles::           How makefiles get remade.
* Overriding Makefiles::         How to override part of one makefile
                                 with another makefile.

 

File: make-info,  Node: Makefile Contents,  Next: Makefile Names,  Prev: Makefiles,  Up: Makefiles

What Makefiles Contain
======================

Makefiles contain four kinds of things: "rules", "variable
definitions", "directives" and "comments".  Rules, variables and
directives are described at length in later chapters.

   * A rule says when and how to remake one or more files, called the
     rule's "targets".  It lists the other files that the targets
     "depend on", and may also give commands to use to create or
     update the targets.  *Note Rules::.

   * A variable definition is a line that specifies a text string
     value for a "variable" that can be substituted into the text
     later.  The simple makefile example (*note Simple::.) shows a
     variable definition for `objects' as a list of all object files.
     *Note Variables::, for full details.

   * A directive is a command for `make' to do something special
     while reading the makefile.  These include:

        * Reading another makefile (*note Include::.).

        * Deciding (based on the values of variables) whether to use
          or ignore a part of the makefile (*note Conditionals::.).

        * Defining a variable from a verbatim string containing
          multiple lines (*note Defining::.).

   * `#' in a line of a makefile starts a comment.  It and the rest
     of the line are ignored, except that a trailing backslash not
     escaped by another backslash will continue the comment across
     multiple lines.  Comments may appear on any of the lines in the
     makefile, except within a `define' directive, and perhaps within
     commands (where the shell decides what is a comment).  A line
     containing just a comment (with perhaps spaces before it) is
     effectively blank, and is ignored.



File: make-info,  Node: Makefile Names,  Next: Include,  Prev: Makefile Contents,  Up: Makefiles

What Name to Give Your Makefile
===============================

By default, when `make' looks for the makefile, it tries the names
`GNUmakefile', `makefile' and `Makefile', in that order.

Normally you should call your makefile either `makefile' or
`Makefile'.  (We recommend `Makefile' because it appears prominently
near the beginning of a directory listing, right near other important
files such as `README'.)  The first name checked, `GNUmakefile', is
not recommended for most makefiles.  You should use this name if you
have a makefile that is specific to GNU `make', and will not be
understood by other versions of `make'.

If `make' finds none of these names, it does not use any makefile. 
Then you must specify a goal with a command argument, and `make' will
attempt to figure out how to remake it using only its built-in
implicit rules.  *Note Implicit::.

If you want to use a nonstandard name for your makefile, you can
specify the makefile name with the `-f' option.  The arguments `-f
NAME' tell `make' to read the file NAME as the makefile.  If you use
more than one `-f' option, you can specify several makefiles.  All
the makefiles are effectively concatenated in the order specified. 
The default makefile names `GNUmakefile', `makefile' and `Makefile'
are not checked automatically if you specify `-f'.



File: make-info,  Node: Include,  Next: MAKEFILES Variable,  Prev: Makefile Names,  Up: Makefiles

Including Other Makefiles
=========================

The `include' directive tells `make' to suspend reading the current
makefile and read another makefile before continuing.  The directive
is a line in the makefile that looks like this:

     include FILENAME

Extra spaces are allowed and ignored at the beginning of the line,
but a tab is not allowed.  (If the line begins with a tab, it will be
considered a command line.)  Whitespace is required between `include'
and FILENAME; extra whitespace is ignored there and at the end of the
directive.  A comment starting with `#' is allowed at the end of the
line.  If FILENAME contains any variable or function references, they
are expanded.  (*Note Variables::.)

When `make' processes an `include' directive, it suspends reading of
the containing makefile and reads from FILENAME instead.  When that
is finished, `make' resumes reading the makefile in which the
directive appears.

One occasion for using `include' directives is when several programs,
handled by individual makefiles in various directories, need to use a
common set of variable definitions (*note Setting::.) or pattern
rules (*note Pattern Rules::.).

Another such occasion is when you want to automatically generate
dependencies from source files; the dependencies can be put in a file
that is included by the main makefile.  This practice is generally
cleaner than that of somehow appending the dependencies to the end of
the main makefile as has been traditionally done with other versions
of `make'.

If the specified name does not start with a slash, and the file is
not found in the current directory, several other directories are
searched.  First, any directories you have specified with the `-I'
option are searched (*note Options::.).  Then the following
directories (if they exist) are searched, in this order:
`/usr/gnu/include', `/usr/local/include', `/usr/include'.  If an
included makefile cannot be found in any of these directories, a
warning message is generated, but it is not a fatal error; processing
of the makefile containing the `include' continues.



File: make-info,  Node: MAKEFILES Variable,  Next: Remaking Makefiles,  Prev: Include,  Up: Makefiles

The Variable `MAKEFILES'
========================

If the environment variable `MAKEFILES' is defined, `make' considers
its value as a list of names (separated by whitespace) of additional
makefiles to be read before the others.  This works much like the
`include' directive: various directories are searched for those files
(*note Include::.).  In addition, the default goal is never taken
from one of these makefiles and it is not an error if the files
listed in `MAKEFILES' are not found.

The main use of `MAKEFILES' is in communication between recursive
invocations of `make' (*note Recursion::.).  It usually isn't
desirable to set the environment variable before a top-level
invocation of `make', because it is usually better not to mess with a
makefile from outside.  However, if you are running `make' without a
specific makefile, a makefile in `MAKEFILES' can do useful things to
help the built-in implicit rules work better, such as defining search
paths.

Some users are tempted to set `MAKEFILES' in the environment
automatically on login, and program makefiles to expect this to be
done.  This is a very bad idea, because such makefiles will fail to
work if run by anyone else.  It is much better to write explicit
`include' directives in the makefiles.



File: make-info,  Node: Remaking Makefiles,  Next: Overriding Makefiles,  Prev: MAKEFILES Variable,  Up: Makefiles

How Makefiles Are Remade
========================

Sometimes makefiles can be remade from other files, such as RCS or
SCCS files.  If a makefile can be remade from other files, you
probably want `make' to get an up-to-date version of the makefile to
read in.

To this end, after reading in all makefiles, `make' will consider
each as a goal target and attempt to update it.  If a makefile has a
rule which says how to update it (found either in that very makefile
or in another one) or if an implicit rule applies to it (*note
Implicit::.), it will be updated if necessary.  After all makefiles
have been checked, if any have actually been changed, `make' starts
with a clean slate and reads all the makefiles over again.  (It will
also attempt to update each of them over again, but normally this
will not change them again, since they are already up to date.)

If the makefiles specify commands to remake a file but no
dependencies, the file will always be remade.  In the case of
makefiles, a makefile that has commands but no dependencies will be
remade every time `make' is run, and then again after `make' starts
over and reads the makefiles in again.  This would cause an infinite
loop; `make' would constantly remake the makefile, and never do
anything else.  So, to avoid this, `make' will *not* attempt to
remake makefiles which are specified as targets but have no
dependencies.

If you do not specify any makefiles to be read with `-f' options,
`make' will try the default makefile names; *note Makefile Names::.. 
Unlike makefiles explicitly requested with `-f' options, `make' is
not certain that these makefiles should exist.  However, if a default
makefile does not exist but can be created by running `make' rules,
you probably want the rules to be run so that the makefile can be used.

Therefore, if none of the default makefiles exists, `make' will try
to make each of them in the same order in which they are searched for
(*note Makefile Names::.) until it succeeds in making one, or it runs
out of names to try.  Note that it is not an error if `make' cannot
find or make any makefile; a makefile is not always necessary.

When you use the `-t' option (touch targets), you would not want to
use an out-of-date makefile to decide which targets to touch.  So the
`-t' option has no effect on updating makefiles; they are really
updated even if `-t' is specified.  Likewise, `-q' and `-n' do not
prevent updating of makefiles, because an out-of-date makefile would
result in the wrong output for other targets.  Thus, `make -f mfile
-n foo' will update `mfile', read it in, and then print the commands
to update `foo' and its dependencies without running them.  The
commands printed for `foo' will be those specified in the updated
contents of `mfile'.

However, on occasion you might actually wish to prevent updating of
even the makefiles.  You can do this by specifying the makefiles as
goals in the command line as well as specifying them as makefiles. 
When the makefile name is specified explicitly as a goal, the options
`-t' and so on do apply to them.

Thus, `make -f mfile -n mfile foo' would read the makefile `mfile',
print the commands needed to update it without actually running them,
and then print the commands needed to update `foo' without running
them.  The commands for `foo' will be those specified by the existing
contents of `mfile'.



File: make-info,  Node: Overriding Makefiles,  Prev: Remaking Makefiles,  Up: Makefiles

Overriding Part of One Makefile with Another Makefile
=====================================================

Sometimes it is useful to have a makefile that is mostly just like
another makefile.  You can often use the `include' directive to
include one in the other, and add more targets or variable definitions.
However, if the two makefiles give different commands for the same
target, `make' will not let you just do this.  But there is another
way.

In the containing makefile (the one that wants to include the other),
you can use the `.DEFAULT' special target to say that to remake any
target that cannot be made from the information in the containing
makefile, `make' should look in another makefile.  *Note Last
Resort::, for more information on `.DEFAULT'.

For example, if you have a makefile called `Makefile' that says how
to make the target `foo' (and other targets), you can write a
makefile called `GNUmakefile' that contains:

     foo:
             frobnicate > foo
     
     .DEFAULT:
             @$(MAKE) -f Makefile $@

If you say `make foo', `make' will find `GNUmakefile', read it, and
see that to make `foo', it needs to run the command `frobnicate >
foo'.  If you say `make bar', `make' will find no way to make `bar'
in `GNUmakefile', so it will use the commands from `.DEFAULT': `make
-f Makefile bar'.  If `Makefile' provides a rule for updating `bar',
`make' will apply the rule.  And likewise for any other target that
`GNUmakefile' does not say how to make.



File: make-info,  Node: Rules,  Next: Commands,  Prev: Makefiles,  Up: Top

Writing Rules
*************

A "rule" appears in the makefile and says when and how to remake
certain files, called the rule's "targets" (usually only one per rule).
It lists the other files that are the "dependencies" of the target,
and "commands" to use to create or update the target.

The order of rules is not significant, except for determining the
"default goal": the target for `make' to consider, if you do not
otherwise specify one.  The default goal is the target of the first
rule in the first makefile, except that targets starting with a
period do not count unless they contain slashes as well; also, a
target that defines a pattern rule (*note Pattern Rules::.) or a
suffix rule (*note Suffix Rules::.) has no effect on the default goal.

Therefore, we usually write the makefile so that the first rule is
the one for compiling the entire program or all the programs
described by the makefile.  *Note Goals::.

* Menu:

* Rule Example::        An explained example of a rule.
* Rule Syntax::         General syntax of rules, with explanation.

* Wildcards::           Using wildcard characters like `*' in file names.
* Directory Search::    Searching other directories for source files.

* Phony Targets::       Using a target that isn't a real file's name.
* Force Targets::       A target without commands or dependencies can
                         be used to mark other targets as phony.
* Special Targets::     Targets with special built-in meanings.
* Empty Targets::       Real files that are empty--only the date matters.
* Multiple Targets::    When it is useful to have several targets in a rule.
* Static Pattern::      Static pattern rules apply to multiple targets
                         and can vary the dependencies according to the
                         target name.
* Multiple Rules::      Using several rules with the same target.
* Double-Colon::        Special kind of rule allowing
                          several independent rules for one target.
* Commands::            Special features and details of how commands
                         in a rule are executed.

 

File: make-info,  Node: Rule Example,  Next: Rule Syntax,  Prev: Rules,  Up: Rules

Rule Example
============

Here is an example of a rule:

     foo.o : foo.c defs.h       # module for twiddling the frobs
             cc -c -g foo.c

Its target is `foo.o' and its dependencies are `foo.c' and `defs.h'. 
It has one command, which is `cc -c -g foo.c'.  The command line
starts with a tab to identify it as a command.

This rule says two things:

   * How to decide whether `foo.o' is out of date: it is out of date
     if it does not exist, or if either `foo.c' or `defs.h' is more
     recent than it.

   * How to update the file `foo.o': by running `cc' as stated.  The
     command does not explicitly mention `defs.h', but we presume
     that `foo.c' includes it, and that that is why `defs.h' was
     added to the dependencies.



File: make-info,  Node: Rule Syntax,  Next: Wildcards,  Prev: Rule Example,  Up: Rules

Rule Syntax
===========

In general, a rule looks like this:

     TARGETS : DEPENDENCIES
             COMMAND
             COMMAND
             ...

 or like this:

     TARGETS : DEPENDENCIES ; COMMAND
             COMMAND
             COMMAND
             ...

 The TARGETS are file names, separated by spaces.  Wild card
characters may be used (*note Wildcards::.) and a name of the form
`A(M)' represents member M in archive file A (*note Archive
Members::.).  Usually there is only one target per rule, but
occasionally there is a reason to have more; *Note Multiple Targets::.

The COMMAND lines start with a tab character.  The first command may
appear on the line after the dependencies, with a tab character, or
may appear on the same line, with a semicolon.  Either way, the
effect is the same.  *Note Commands::.

Because dollar signs are used to start variable references, if you
really want a dollar sign in the rule you must write two of them
(`$$').  *Note Variables::.  You may split a long line by inserting a
backslash followed by a newline, but this is not required, as `make'
places no limit on the length of a line in a makefile.

A rule tells `make' two things: when the targets are out of date, and
how to update them when necessary.

The criterion for being out of date is specified in terms of the
DEPENDENCIES, which consist of file names separated by spaces. 
(Wildcards and archive members are allowed here too.)  A target is
out of date if it does not exist or if it is older than any of the
dependencies (by comparison of last-modification times).  The idea is
that the contents of the target file are computed based on
information in the dependencies, so if any of the dependencies
changes, the contents of the existing target file are no longer
necessarily valid.

How to update is specified by COMMANDS.  These are lines to be
executed by the shell (normally `sh'), but with some extra features
(*note Commands::.).



File: make-info,  Node: Wildcards,  Next: Directory Search,  Prev: Rule Syntax,  Up: Rules

Using Wildcards Characters in File Names
========================================

A single file name can specify many files using "wildcard characters".
The wildcard characters in `make' are `*', `?' and `[...]', the same
as in the Bourne shell.  For example, `*.c' specifies a list of all
the files (in the working directory) whose names end in `.c'.

The character `~' at the beginning of a file name also has special
significance.  If alone, or followed by a slash, it represents your
home directory.  For example `~/bin' expands to `/home/you/bin'.  If
the `~' is followed by a word, the string represents the home
directory of the user named by that word.  For example `~me/bin'
expands to `/home/me/bin'.

Wildcard expansion happens automatically in targets, in dependencies,
and in commands.  In other contexts, wildcard expansion happens only
if you request it explicitly with the `wildcard' function.

The special significance of a wildcard character can be turned off by
preceding it with a backslash.  Thus, `foo\*bar' would refer to a
specific file whose name consists of `foo', an asterisk, and `bar'.

* Menu:

* Examples: Wildcard Examples.    Some simple examples.
* Pitfall: Wildcard Pitfall.      `*.o' won't do what you want!
* Function: Wildcard Function.
       How to do wildcard expansion when defining a variable
       using the function `wildcard'.

 

File: make-info,  Node: Wildcard Examples,  Next: Wildcard Pitfall,  Prev: Wildcards,  Up: Wildcards

Wildcard Examples
-----------------

Wildcards can be used in the commands of a rule.  For example, here
is a rule to delete all the object files:

     clean:
             rm -f *.o

Wildcards are also useful in the dependencies of a rule.  With the
following rule in the makefile, `make print' will print all the `.c'
files that have changed since the last time you printed them:

     print: *.c
             lpr -p $?
             touch print

This rule uses `print' as an empty target file; *note Empty Targets::..

Wildcard expansion does not happen when you define a variable.  Thus,
if you write this:

     objects=*.o

then the value of the variable `objects' is the actual string `*.o'. 
However, if you use the value of `objects' in a target, dependency or
command, wildcard expansion will take place at that time.



File: make-info,  Node: Wildcard Pitfall,  Next: Wildcard Function,  Prev: Wildcard Examples,  Up: Wildcards

Pitfalls of Using Wildcards
---------------------------

Now here is an example of a naive way of using wildcard expansion,
that does not do what you would intend.  Suppose you would like to
say that the executable file `foo' is made from all the object files
in the directory, and you write this:

     objects=*.o
     
     foo : $(objects)
             cc -o foo $(CFLAGS) $(objects)

The value of `objects' is the actual string `*.o'.  Wildcard
expansion happens in the rule for `foo', so that each *existing* `.o'
file becomes a dependency of `foo' and will be recompiled if necessary.

But what if you delete all the `.o' files?  Then `*.o' will expand
into *nothing*.  The target `foo' will have no dependencies and would
be remade by linking no object files.  This is not what you want!

Actually it is possible to obtain the desired result with wildcard
expansion, but you need more sophisticated techniques, including the
`wildcard' function and string substitution.

*Note Wildcard Function::.



File: make-info,  Node: Wildcard Function,  Prev: Wildcard Pitfall,  Up: Wildcards

The Function `wildcard'
-----------------------

Wildcard expansion happens automatically in rules.  But wildcard
expansion does not normally take place when a variable is set, or
inside the arguments of a function.  If you want to do wildcard
expansion in such places, you need to use the `wildcard' function,
like this:

     $(wildcard PATTERN)

This string, used anywhere in a makefile, is replaced by a
space-separated list of names of existing files that match the
pattern PATTERN.

One use of the `wildcard' function is to get a list of all the C
source files in a directory, like this:

     $(wildcard *.c)

We can change the list of C source files into a list of object files
by substituting `.o' for `.c' in the result, like this:

     $(subst .c,.o,$(wildcard *.c))

(Here we have used another function, `subst'.  *Note Text Functions::.)

Thus, a makefile to compile all C source files in the directory and
then link them together could be written as follows:

     objects:=$(subst .c,.o,$(wildcard *.c))
     
     foo : $(objects)
             cc -o foo $(LDFLAGS) $(objects)

(This takes advantage of the implicit rule for compiling C programs,
so there is no need to write explicit rules for compiling the files. 
*Note Flavors::, for an explanation of `:=', which is a variant of
`='.)



Date: Fri, 27 Apr 90 06:10:38 PDT
From: Terence_Donahue
To: tdonahue

Info file make-info, produced by Makeinfo, -*- Text -*- from input
file make.texinfo.

This file documents the GNU Make utility.

Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled ``GNU General Public License'' is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translations of the section
entitled ``GNU General Public License'' must be approved for accuracy
by the Foundation.



File: make-info,  Node: Pattern Match,  Next: Match-Anything Rules,  Prev: Automatic,  Up: Pattern Rules

How Patterns Match
------------------

A target pattern is composed of a `%' between a prefix and a suffix,
either or both of which may be empty.  The pattern matches a file
name only if the file name starts with the prefix and ends with the
suffix, without overlap.  The text between the prefix and the suffix
is called the "stem".  Thus, when the pattern `%.o' matches the file
name `test.o', the stem is `test'.  The pattern rule dependencies are
turned into actual file names by substituting the stem for the
character `%'.  Thus, if in the same example one of the dependencies
is written as `%.c', it expands to `test.c'.

When the target pattern does not contain a slash (and usually it does
not), directory names in the file names are removed from the file
name before it is compared with the target prefix and suffix.  The
directory names, along with the slash that ends them, are added back
to the stem.  Thus, `e%t' does match the file name `src/eat', with
`src/a' as the stem.  When dependencies are turned into file names,
the directories from the stem are added at the front, while the rest
of the stem is substituted for the `%'.  The stem `src/a' with a
dependency pattern `c%r' gives the file name `src/car'.



File: make-info,  Node: Match-Anything Rules,  Next: Canceling Rules,  Prev: Pattern Match,  Up: Pattern Rules

Match-Anything Pattern Rules
----------------------------

When a pattern rule's target is just `%', it matches any filename
whatever.  We call these rules "match-anything" rules.  They are very
useful, but it can take a lot of time for `make' to think about them,
because it must consider every such rule for each file name listed
either as a target or as a dependency.

Suppose the makefile mentions `foo.c'.  For this target, `make' would
have to consider making it by linking an object file `foo.c.o', or by
C compilation-and-linking in one step from `foo.c.c', or by Pascal
compilation-and-linking from `foo.c.p', and many other possibilities.

We know these possibilities are ridiculous since `foo.c' is a C
source file, not an executable.  If `make' did consider these
possibilities, it would ultimately reject them, because files such as
`foo.c.o', `foo.c.p', etc. would not exist.  But these possibilities
are so numerous that `make' would run very slowly if it had to
consider them.

To gain speed, we have put various constraints on the way `make'
considers match-anything rules.  There are two different constraints
that can be applied, and each time you define a match-anything rule
you must choose one or the other for that rule.

One choice is to mark the match-anything rule as "terminal" by
defining it with a double colon.  When a rule is terminal, it does
not apply unless its dependencies actually exist.  Dependencies that
could be made with other implicit rules are not good enough.  In
other words, no further chaining is allowed beyond a terminal rule.

For example, the built-in implicit rules for extracting sources from
RCS and SCCS files are terminal; as a result, if the file `foo.c,v'
does not exist, `make' will not even consider trying to make it as an
intermediate file from `foo.c,v.o' or from `RCS/SCCS/s.foo.c,v'.  RCS
and SCCS files are generally ultimate source files, which should not
be remade from any other files; therefore, `make' can save time by
not looking for ways to remake them.

If you do not mark the match-anything rule as terminal, then it is
nonterminal.  A nonterminal match-anything rule cannot apply to a
file name that indicates a specific type of data.  A file name
indicates a specific type of data if some non-match-anything implicit
rule target matches it.

For example, the file name `foo.c' matches the target for the pattern
rule `%.c : %.y' (the rule to run Yacc).  Regardless of whether this
rule is actually applicable (which happens only if there is a file
`foo.y'), the fact that its target matches is enough to prevent
consideration of any nonterminal match-anything rules for the file
`foo.c'.  Thus, `make' will not even consider trying to make `foo.c'
as an executable file from `foo.c.o', `foo.c.c', `foo.c.p', etc.

The motivation for this constraint is that nonterminal match-anything
rules are used for making files containing specific types of data
(such as executable files) and a file name with a recognized suffix
indicates some other specific type of data (such as a C source file).

Special built-in dummy pattern rules are provided solely to recognize
certain file names so that nonterminal match-anything rules won't be
considered.  These dummy rules have no dependencies and no commands,
and they are ignored for all other purposes.  For example, the
built-in implicit rule

     %.p :

exists to make sure that Pascal source files such as `foo.p' match a
specific target pattern and thereby prevent time from being wasted
looking for `foo.p.o' or `foo.p.c'.

Dummy pattern rules such as the one for `%.p' are made for every
suffix listed as valid for use in suffix rules.  *Note Suffix Rules::.



File: make-info,  Node: Canceling Rules,  Prev: Match-Anything Rules,  Up: Pattern Rules

Canceling Implicit Rules
------------------------

You can override a built-in implicit rule by defining a new pattern
rule with the same target and dependencies, but different commands. 
When the new rule is defined, the built-in one is replaced.  The new
rule's position in the sequence of implicit rules is determined by
where you write the new rule.

You can cancel a built-in implicit rule by defining a pattern rule
with the same target and dependencies, but no commands.  For example,
the following would cancel the rule that runs the assembler:

     %.o : %.s



File: make-info,  Node: Last Resort,  Next: Suffix Rules,  Prev: Pattern Rules,  Up: Implicit

Defining Last-Resort Default Rules
==================================

You can define a last-resort implicit rule by writing a rule for the
target `.DEFAULT'.  Such a rule's commands are used for all targets
and dependencies that have no commands of their own and for which no
other implicit rule applies.  Naturally, there is no `.DEFAULT' rule
unless you write one.

For example, when testing a makefile, you might not care if the
source files contain real data, only that they exist.  Then you might
do this:

     .DEFAULT:
             touch $@

to cause all the source files needed (as dependencies) to be created
automatically.

If you give `.DEFAULT' with no commands or dependencies:

     .DEFAULT:

the commands previously stored for `.DEFAULT' are cleared.  Then
`make' acts as if you had never defined `.DEFAULT' at all.

If you want a target not to get the commands from `.DEFAULT', but nor
do you want any commands to be run for the target, you can give it
empty commands.  *Note Empty Commands::.



File: make-info,  Node: Suffix Rules,  Next: Search Algorithm,  Prev: Last Resort,  Up: Implicit

Old-Fashioned Suffix Rules
==========================

"Suffix rules" are the old-fashioned way of defining implicit rules
for `make'.  Suffix rules are obsolete because pattern rules are more
general and clearer.  They are supported in GNU `make' for
compatibility with old makefiles.  They come in two kinds:
"double-suffix" and "single-suffix".

A double-suffix rule is defined by a pair of suffixes: the target
suffix and the source suffix.  It matches any file whose name ends
with the target suffix.  The corresponding implicit dependency is to
the file name made by replacing the target suffix with the source
suffix.  A two-suffix rule whose target and source suffixes are `.o'
and `.c' is equivalent to the pattern rule `%.o : %.c'.

A single-suffix rule is defined by a single suffix, which is the
source suffix.  It matches any file name, and the corresponding
implicit dependency name is made by appending the source suffix.  A
single-suffix rule whose source suffix is `.c' is equivalent to the
pattern rule `% : %.c'.

Suffix rule definitions are recognized by comparing each rule's
target against a defined list of known suffixes.  When `make' sees a
rule whose target is a known suffix, this rule is considered a
single-suffix rule.  When `make' sees a rule whose target is two
known suffixes concatenated, this rule is taken as a double-suffix
rule.

For example, `.c' and `.o' are both on the default list of known
suffixes.  Therefore, if you define a rule whose target is `.c.o',
`make' takes it to be a double-suffix rule with source suffix `.c'
and target suffix `.o'.  For example, here is the old fashioned way
to define the rule for compiling a C source:

     .c.o:
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<

Suffix rules cannot have any dependencies of their own.  If they have
any, they are treated as normal files with funny names, not as suffix
rules.  Thus, the rule:

     .c.o: foo.h
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<

tells how to make the file `.c.o' from the dependency file `foo.h',
and is not at all like the pattern rule:

     %.o: %.c foo.h
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<

which tells how to make `.o' files from `.c' files, and makes all
`.o' files using this pattern rule also depend on `foo.h'.

Suffix rules with no commands are also meaningless.  They do not
remove previous rules as do pattern rules with no commands (*note
Canceling Rules::.).  They simply enter the suffix or pair of
suffixes concatenated as a target in the data base.

The known suffixes are simply the names of the dependencies of the
special target `.SUFFIXES'.  You can add your own suffixes by writing
a rule for `.SUFFIXES' that adds more dependencies, as in:

     .SUFFIXES: .hack .win

which adds `.hack' and `.win' to the end of the list of suffixes.

If you wish to eliminate the default known suffixes instead of just
adding to them, write a rule for `.SUFFIXES' with no dependencies. 
By special dispensation, this eliminates all existing dependencies of
`.SUFFIXES'.  You can then write another rule to add the suffixes you
want.  For example,

     .SUFFIXES:    # Delete the default suffixes
     .SUFFIXES: .c .o .h   # Define our suffix list

The `-r' flag causes the default list of suffixes to be empty.

The variable `SUFFIXES' is defined to the default list of suffixes
before `make' reads any makefiles.  You can change the list of
suffixes with a rule for the special target `.SUFFIXES', but that
does not alter this variable.



File: make-info,  Node: Search Algorithm,  Prev: Suffix Rules,  Up: Implicit

Implicit Rule Search Algorithm
==============================

Here is the procedure `make' uses for searching for an implicit rule
for a target T.  This procedure is followed for each double-colon
rule with no commands, for each target of ordinary rules none of
which have commands, and for each dependency that is not the target
of any rule.  It is also followed recursively for dependencies that
come from implicit rules, in the search for a chain of rules.

Suffix rules are not mentioned in this algorithm because suffix rules
are converted to equivalent pattern rules once the makefiles have
been read in.

For an archive member target of the form `ARCHIVE(MEMBER)', the
following algorithm is run twice, first using `(MEMBER)' as the
target T, and second using the entire target if the first run found
no rule.

  1. Split T into a directory part, called D, and the rest, called N.
     For example, if T is `src/foo.o', then D is `src/' and N is
     `foo.o'.

  2. Make a list of all the pattern rules one of whose targets
     matches T or N.  If the target pattern contains a slash, it is
     matched against T; otherwise, against N.

  3. If any rule in that list is *not* a match-anything rule, then
     remove all nonterminal match-anything rules from the list.

  4. Remove from the list all rules with no commands.

  5. For each pattern rule in the list:

       1. Find the stem S, which is the nonempty part of T or N
          matched by the `%' in the target pattern.

       2. Compute the dependency names by substituting S for `%'; if
          the target pattern does not contain a slash, append D to
          the front of each dependency name.

       3. Test whether all the dependencies exist or ought to exist. 
          (If a file name is mentioned in the makefile as a target or
          as an explicit dependency then we say it ought to exist.)

          If all dependencies exist or ought to exist, or there are
          no dependencies, then this rule applies.

  6. If no pattern rule has been found so far, try harder.  For each
     pattern rule in the list:

       1. If the rule is terminal, ignore it and go on to the next
          rule.

       2. Compute the dependency names as before.

       3. Test whether all the dependencies exist or ought to exist.

       4. For each dependency that does not exist, follow this
          algorithm recursively to see if the dependency can be made
          by an implicit rule.

       5. If all dependencies exist, ought to exist, or can be made
          by implicit rules, then this rule applies.

  7. If no implicit rule applies, the rule for `.DEFAULT', if any,
     applies.  In that case, give T the same commands that `.DEFAULT'
     has.  Otherwise, there are no commands for T.

Once a rule that applies has been found, for each target pattern of
the rule other than the one that matched T or N, the `%' in the
pattern is replaced with S and the resultant file name is stored
until the commands to remake the target file T are executed.  After
these commands are executed, each of these stored file names are
entered into the data base and marked as having been updated and
having the same update status as the file T.

When the commands of a pattern rule are executed for T, the automatic
variables are set corresponding to the target and dependencies. 
*Note Automatic::.



File: make-info,  Node: Archives,  Next: Features,  Prev: Implicit,  Up: Top

Using `make' to Update Archive Files
************************************

"Archive files" are files containing named subfiles called "members";
they are maintained with the program `ar' and their main use is as
subroutine libraries for linking.

* Menu:

* Members: Archive Members.    How to name an archive member
                                as a target or dependency.
* Update: Archive Update.      An implicit rule can update
                                most archive member targets just right.
* Symbols: Archive Symbols.    Special things to do for library archives.

 

File: make-info,  Node: Archive Members,  Next: Archive Update,  Prev: Archives,  Up: Archives

Archive Members as Targets
==========================

An individual member of an archive file can be used as a target or
dependency in `make'.  The archive file must already exist, but the
member need not exist.  You specify the member named MEMBER in
archive file ARCHIVE as follows:

     ARCHIVE(MEMBER)

This construct is available only in targets and dependencies, not in
commands!  Most programs that you might use in commands do not
support this syntax and cannot act directly on archive members.  Only
`ar' and other programs specifically designed to operate on archives
can do so.  Therefore, valid commands to update an archive member
target probably must use `ar'.  For example, this rule says to create
a member `hack.o' in archive `foolib' by copying the file `hack.o':

     foolib(hack.o) : hack.o
             ar r foolib hack.o

In fact, nearly all archive member targets are updated in just this
way and there is an implicit rule to do it for you.



File: make-info,  Node: Archive Update,  Next: Archive Symbols,  Prev: Archive Members,  Up: Archives

Implicit Rule for Archive Member Targets
========================================

Recall that a target that looks like `A(M)' stands for the member
named M in the archive file A.

When `make' looks for an implicit rule for such a target, as a
special feature it considers implicit rules that match `(M)', as well
as those that match the actual target `A(M)'.

This causes one special rule whose target is `(%)' to match.  This
rule updates the target `A(M)' by copying the file M into the
archive.  For example, it will update the archive member target
`foo.a(bar.o)' by copying the *file* `bar.o' into the archive `foo.a'
as a *member* named `bar.o'.

When this rule is chained with others, the result is very powerful. 
Thus, `make "foo.a(bar.o)"' in the presence of a file `bar.c' is
enough to cause the following commands to be run, even without a
makefile:

     cc -c bar.c -o bar.o
     ar r foo.a bar.o
     rm -f bar.o

Here `make' has envisioned the file `bar.o' as an intermediate file.

Implicit rules such as this one are written using the automatic
variable `$%'.  *Note Automatic::.

An archive member name in an archive cannot contain a directory name,
but it may be useful in a makefile to pretend that it does.  If you
write an archive member target `foo.a(dir/file.o)', `make' will
perform automatic updating with this command:

     ar r foo.a dir/file.o

which has the effect of copying the file `dir/foo.o' into a member
named `foo.o'.  In connection with such usage, the automatic
variables `%D' and `%F' may be useful.



File: make-info,  Node: Archive Symbols,  Prev: Archive Update,  Up: Archives

Updating Archive Symbol Directories
-----------------------------------

An archive file that is used as a library usually contains a special
member named `__.SYMDEF' that contains a directory of the external
symbol names defined by all the other members.  After you update any
other members, you need to update `__.SYMDEF' so that it will
summarize the other members properly.  This is done by running the
`ranlib' program:

     ranlib ARCHIVEFILE

Normally you would put this command in the rule for the archive file,
and make all the members of the archive file dependents of that rule.
For example,

     libfoo.a: libfoo.a(x.o) libfoo.a(y.o) ...
             ranlib libfoo.a

The effect of this is to update archive members `x.o', `y.o', etc.,
and then update the symbol directory member `__.SYMDEF' by running
`ranlib'.  The rules for updating the members are not shown here;
most likely you can omit them and use the implicit rule which copies
files into the archive, as described in the preceding section.

This is not necessary when using the GNU `ar' program, which updates
the `__.SYMDEF' member automatically.



File: make-info,  Node: Features,  Next: Missing,  Prev: Archives,  Up: Top

Features of GNU `make'
**********************

Here is a summary of the features of GNU `make', for comparison with
and credit to other versions of `make'.  We consider the features of
`make' in BSD 4.2 systems as a baseline.

Many features come from the version of `make' in System V.

   * The `VPATH' variable and its special meaning.  *Note Directory
     Search::.  This feature exists in System V `make', but is
     undocumented.  It is documented in 4.3 BSD `make' (which says it
     mimics System V's `VPATH' feature).

   * Included makefiles.  *Note Include::.

   * Variables are read from and communicated via the environment. 
     *Note Environment::.

   * Options passed through the variable `MAKEFLAGS' to recursive
     invocations of `make'.  *Note Options/Recursion::.

   * The automatic variable `$%' is set to the member name in an
     archive reference.  *Note Automatic::.

   * The automatic variables `$@', `$*', `$<' and `$%' have
     corresponding forms like `$(@F)' and `$(@D)'.  *Note Automatic::.

   * Substitution variable references.  *Note Reference::.

   * The command-line options `-b' and `-m', accepted and ignored.

   * Execution of recursive commands to run `make' via the variable
     `MAKE' even if `-n', `-q' or `-t' is specified.  *Note
     Recursion::.

   * Support for suffix `.a' in suffix rules.  In GNU `make', this is
     actually implemented by chaining with one pattern rule for
     installing members in an archive.  *Note Chained Rules::.

   * The arrangement of lines and backslash-newline combinations in
     commands is retained when the commands are printed, so they
     appear as they do in the makefile, except for the stripping of
     initial whitespace.

The following features were inspired by various other versions of
`make'.  In some cases it is unclear exactly which versions inspired
which others.

   * Pattern rules using `%'.  This has been implemented in several
     versions of `make'.  We're not sure who invented it first, but
     it's been spread around a bit.  *Note Pattern Rules::.

   * Rule chaining and implicit intermediate files.  This was
     implemented by Stu Feldman in his version of `make' for AT&T
     Eighth Edition Research Unix, and later by Andrew Hume of AT&T
     Bell Labs in his `mk' program.  We don't really know if we got
     this from either of them or thought it up ourselves at the same
     time.  *Note Chained Rules::.

   * The automatic variable `$^' containing a list of all
     dependencies of the current target.  We didn't invent this, but
     we have no idea who did.  *Note Automatic::.

   * The ``what if'' flag (`-W' in GNU `make') was (as far as we
     know) invented by Andrew Hume in `mk'.  *Note Instead of
     Execution::.

   * The concept of doing several things at once (parallelism) exists
     in many incarnations of `make' and similar programs, though not
     in the System V or BSD implementations.  *Note Execution::.

   * Modified variable references using pattern substitution come
     from SunOS 4.0.  *Note Reference::.  This functionality was
     provided in GNU `make' by the `patsubst' function before the
     alternate syntax was implemented for compatibility with SunOS
     4.0.  It is not altogether clear who inspired whom, since GNU
     `make' had `patsubst' before SunOS 4.0 was released.

   * The special significance of `+' characters preceding command
     lines (*note Instead of Execution::.) is mandated by draft 8 of
     IEEE Std 1003.2 (POSIX).

The remaining features are inventions new in GNU `make':

   * The `-v' option to print version and copyright information.

   * Simply-expanded variables.  *Note Flavors::.

   * Passing command-line variable assignments automatically through
     the variable `MAKE' to recursive `make' invocations.  *Note
     Recursion::.

   * The `-C' command option to change directory.  *Note Options::.

   * Verbatim variable definitions made with `define'.  *Note
     Defining::.

   * Phony targets declared with the special target `.PHONY'.  A
     similar feature with a different syntax was implemented by
     Andrew Hume of AT&T Bell Labs in his `mk' program.  This seems
     to be a case of parallel discovery.  *Note Phony Targets::.

   * Text manipulation by calling functions.  *Note Functions::.

   * The `-o' option to pretend a file's modification-time is old. 
     *Note Avoiding Compilation::.

   * Conditional execution.  This has been implemented numerous times
     in various versions of `make'; it seems a natural extension
     derived from the features of the C preprocessor and similar
     macro languages and is not a revolutionary concept.  *Note
     Conditionals::.

   * The included makefile search path.  *Note Include::.

   * Specifying extra makefiles to read.  *Note MAKEFILES Variable::.

   * Stripping leading sequences of `./' from file names, so that
     `./FILE' and `FILE' are considered to be the same file.

   * Special search method for library dependencies written in the
     form `-lNAME'.  *Note Libraries/Search::.

   * Allowing suffixes for suffix rules (*note Suffix Rules::.) to
     contain any characters.  In other version of `make', they must
     begin with `.' and not contain any `/' characters.

   * The variable `MAKELEVEL' which keeps track of the current level
     of `make' recursion.  *Note Recursion::.

   * Static pattern rules.  *Note Static Pattern::.

   * Selective `vpath' search.  *Note Directory Search::.

   * Recursive variable references.  *Note Reference::.

   * Updated makefiles.  *Note Remaking Makefiles::.  System V `make'
     has a very, very limited form of this functionality in that it
     will check out SCCS files for makefiles.

   * Several new built-in implicit rules.  *Note Catalogue of Rules::.



File: make-info,  Node: Missing,  Next: Concept Index,  Prev: Features,  Up: Top

Missing Features in GNU `make'
******************************

The `make' programs in various other systems support a few features
that are not implemented in GNU `make'.

   * A target of the form `FILE((ENTRY))' stands for a member of
     archive file FILE.  The member is chosen, not by name, but by
     being an object file which defines the linker symbol ENTRY.

     This feature was not put into GNU `make' because of the
     nonmodularity of putting knowledge into `make' of the internal
     format of archive file symbol directories.  *Note Archive
     Symbols::.

   * Suffixes (used in suffix rules) that end with the character `~'
     have a special meaning; they refer to the SCCS file that
     corresponds to the file one would get without the `~'.  For
     example, the suffix rule `.c~.o' would make the file `N.o' file
     from the SCCS file `s.N.c'.  For complete coverage, a whole
     series of such suffix rules is required.  *Note Suffix Rules::.

     In GNU `make', this entire series of cases is handled by two
     pattern rules for extraction from SCCS, in combination with the
     general feature of rule chaining.  *Note Chained Rules::.

   * In System V `make', the string `$$@' has the strange meaning
     that, in the dependencies of a rule with multiple targets, it
     stands for the particular target that is being processed.

     This is not defined in GNU `make' because `$$' should always
     stand for an ordinary `$'.

     It is possible to get this functionality through the use of
     static pattern rules (*note Static Pattern::.).  The System V
     `make' rule:

          $(targets): $$@.o lib.a

     can be replaced with the GNU `make' static pattern rule:

          $(targets): %: %.o lib.a

   * In System V and 4.3 BSD `make', files found by `VPATH' search
     (*note Directory Search::.) have their names changed inside
     command strings.  We feel it is much cleaner to always use
     automatic variables and thus make this feature obsolete.  We are
     still debating whether to implement this for the sake of
     compatibility or to leave it out to avoid such terrible ugliness.



File: make-info,  Node: Concept Index,  Next: Name Index,  Prev: Missing,  Up: Top

Index of Concepts
*****************

* Menu:

* $ (function call): Syntax of Functions.
* - (in commands): Errors.
* :=: Setting.
* =: Setting.
* @ (in commands): Echoing.
* `-W': Instead of Execution.
* `-f': Makefile Names.
* `-i': Errors.
* `-k': Testing.
* `-n': Instead of Execution.
* `-o': Avoiding Compilation.
* `-q': Instead of Execution.
* `-s': Echoing.
* `-t': Instead of Execution.
* __.SYMDEF: Archive Symbols.
* archive: Archives.
* archive member targets: Archive Members.
* arguments: Syntax of Functions.
* automatic variables: Automatic.
* backquotes: Shell Function.
* chains of rules: Chained Rules.
* command expansion: Shell Function.
* commands: Commands.
* comments: Makefile Contents.
* computed variable name: Computed Names.
* conditionals: Conditionals.
* default makefile names: Makefile Names.
* deletion of target files: Interrupts.
* dependency: Rules.
* directory search: Directory Search.
* double-colon rule: Double-Colon.
* echoing (of commands): Echoing.
* empty commands: Empty Commands.
* empty targets: Empty Targets.
* environment: Environment.
* environment and recursion: Variables/Recursion.
* error (in commands): Errors.
* execution: Execution.
* execution in parallel: Parallel.
* file name: Wildcards.
* flags: Options.
* flags for compilers: Implicit Variables.
* flavors (of variables): Flavors.
* function: Functions.
* goal: Goals.
* implicit rule: Implicit.
* intermediate file: Chained Rules.
* interrupt: Interrupts.
* job slots: Parallel.
* makefile: Makefiles.
* makefile names: Makefile Names.
* makefiles, remaking of: Remaking Makefiles.
* match-anything rule: Match-Anything Rules.
* modified variable reference: Substitution Refs.
* names of makefiles: Makefile Names.
* nested variable reference: Computed Names.
* options: Options.
* options and recursion: Options/Recursion.
* options, setting from the environment: Options/Recursion.
* options, setting in makefiles: Options/Recursion.
* overriding makefiles: Overriding Makefiles.
* overriding variables with arguments: Overriding.
* overriding with `override': Override Directive.
* parallel execution: Parallel.
* pattern rule: Pattern Intro.
* phony targets: Phony Targets.
* precious targets: Special Targets.
* preserving intermediate files with .PRECIOUS: Chained Rules.
* question mode: Instead of Execution.
* recursion: Recursion.
* recursive variable expansion: Flavors.
* recursive variable expansion: Variables.
* reference to variables: Advanced.
* remaking makefiles: Remaking Makefiles.
* rule: Rules.
* search path for dependencies: Directory Search.
* sequences of commands: Sequences.
* setting options from the environment: Options/Recursion.
* setting options in makefiles: Options/Recursion.
* setting variables: Setting.
* shell: Execution.
* signal: Interrupts.
* silent operation: Echoing.
* simple variable expansion: Variables.
* special targets: Special Targets.
* static pattern rules: Static Pattern.
* stem: Pattern Match.
* substitution variable reference: Substitution Refs.
* suffix rules: Suffix Rules.
* target: Rules.
* terminal rule: Match-Anything Rules.
* testing compilation: Testing.
* touching files: Instead of Execution.
* updating makefiles: Remaking Makefiles.
* value: Variables.
* variable: Variables.
* variable reference, nested: Computed Names.
* varying dependencies: Static Pattern.
* vpath: Directory Search.
* what if: Instead of Execution.
* wildcard: Wildcards.
* ~: Wildcards.


 

File: make-info,  Node: Name Index,  Prev: Concept Index,  Up: Top

Index of Functions, Variables, and Directives
*********************************************

* Menu:

* .DEFAULT: Last Resort.
* .IGNORE: Errors.
* .PHONY: Phony Targets.
* .PRECIOUS: Interrupts.
* .SILENT: Echoing.
* .SUFFIXES: Suffix Rules.
* AR: Implicit Variables.
* ARFLAGS: Implicit Variables.
* AS: Implicit Variables.
* ASFLAGS: Implicit Variables.
* C++: Implicit Variables.
* C++FLAGS: Implicit Variables.
* CC: Implicit Variables.
* CFLAGS: Implicit Variables.
* CO: Implicit Variables.
* COFLAGS: Implicit Variables.
* CPP: Implicit Variables.
* CPPFLAGS: Implicit Variables.
* CTANGLE: Implicit Variables.
* CWEAVE: Implicit Variables.
* EC: Implicit Variables.
* EFLAGS: Implicit Variables.
* FC: Implicit Variables.
* FC: Implicit Variables.
* FFLAGS: Implicit Variables.
* GET: Implicit Variables.
* GFLAGS: Implicit Variables.
* LDFLAGS: Implicit Variables.
* LEX: Implicit Variables.
* LFLAGS: Implicit Variables.
* MAKE: MAKE Variable.
* MAKEFILES: MAKEFILES Variable.
* MAKEFILES: Variables/Recursion.
* MAKEFLAGS: Options/Recursion.
* MAKEINFO: Implicit Variables.
* MAKELEVEL: Variables/Recursion.
* MFLAGS: Options/Recursion.
* PC: Implicit Variables.
* PFLAGS: Implicit Variables.
* RC: Implicit Variables.
* RFLAGS: Implicit Variables.
* RM: Implicit Variables.
* SHELL: Execution.
* SUFFIXES: Suffix Rules.
* TANGLE: Implicit Variables.
* TEX: Implicit Variables.
* TEXINDEX: Implicit Variables.
* VPATH: Directory Search.
* WEAVE: Implicit Variables.
* YACC: Implicit Variables.
* YACCE: Implicit Variables.
* YACCR: Implicit Variables.
* YFLAGS: Implicit Variables.
* addprefix: Filename Functions.
* addsuffix: Filename Functions.
* basename: Filename Functions.
* define: Defining.
* dir: Filename Functions.
* else: Conditional Syntax.
* endef: Defining.
* endif: Conditional Syntax.
* filter: Text Functions.
* filter-out: Text Functions.
* findstring: Text Functions.
* firstword: Filename Functions.
* foreach: Foreach Function.
* ifdef: Conditional Syntax.
* ifeq: Conditional Syntax.
* ifndef: Conditional Syntax.
* ifneq: Conditional Syntax.
* include: Include.
* join: Filename Functions.
* notdir: Filename Functions.
* objects: Simple.
* origin: Origin Function.
* override: Override Directive.
* patsubst: Text Functions.
* shell: Shell Function.
* sort: Text Functions.
* strip: Text Functions.
* subst: Text Functions.
* suffix: Filename Functions.
* vpath: Directory Search.
* wildcard: Wildcard Function.
* wildcard: Filename Functions.
* word: Filename Functions.
* words: Filename Functions.


 
Tag Table:
Node: Top1011
Node: Overview2636
Node: Copying4052
Node: Bugs17391
Node: Simple18906
Node: Makefiles28217
Node: Makefile Contents28934
Node: Makefile Names30754
Node: Include32179
Node: MAKEFILES Variable34376
Node: Remaking Makefiles35751
Node: Overriding Makefiles39248
Node: Rules40830
Node: Rule Example43021
Node: Rule Syntax43864
Node: Wildcards45906
Node: Wildcard Examples47378
Node: Wildcard Pitfall48312
Node: Wildcard Function49432
Node: Directory Search50826
Node: General Search51845
Node: Selective Search52950
Node: Commands/Search55536
Node: Implicit/Search57052
Node: Libraries/Search57955
Node: Phony Targets59403
Node: Force Targets61948
Node: Empty Targets62912
Node: Special Targets64145
Node: Multiple Targets66741
Node: Static Pattern68438
Node: Static Usage69061
Node: Static vs Implicit72177
Node: Multiple Rules73856
Node: Double-Colon75481
Node: Commands76936
Node: Echoing78468
Node: Execution79628
Node: Parallel81272
Node: Errors84470
Node: Interrupts87207
Node: Recursion88780
Node: MAKE Variable89992
Node: Variables/Recursion91808
Node: Options/Recursion93820
Node: -w Option96453
Node: Sequences97065
Node: Empty Commands99009
Node: Variables100113
Node: Reference101923
Node: Flavors103430
Node: Advanced106941
Node: Substitution Refs107383
Node: Computed Names108810
Node: Values112927
Node: Setting113670
Node: Override Directive115133
Node: Defining116296
Node: Environment117856
Node: Conditionals119888
Node: Conditional Example120623
Node: Conditional Syntax123137
Node: Testing Flags126377
Node: Functions127498
Node: Syntax of Functions128446
Node: Text Functions130738
Node: Filename Functions136023
Node: Foreach Function141276
Node: Origin Function144452
Node: Shell Function147433
Node: Running148776
Node: Makefile Arguments150231
Node: Goals150851
Node: Instead of Execution154083
Node: Avoiding Compilation156975
Node: Overriding158840
Node: Testing161021
Node: Options162835
Node: Implicit167914
Node: Using Implicit169797
Node: Catalogue of Rules172569
Node: Implicit Variables180063
Node: Chained Rules184494
Node: Pattern Rules187224
Node: Pattern Intro188747
Node: Pattern Examples191592
Node: Automatic193296
Node: Pattern Match197910
Node: Match-Anything Rules199245
Node: Canceling Rules203044
Node: Last Resort203707
Node: Suffix Rules204819
Node: Search Algorithm208440
Node: Archives211901
Node: Archive Members212564
Node: Archive Update213632
Node: Archive Symbols215283
Node: Features216489
Node: Missing222407
Node: Concept Index224651
Node: Name Index228194

Date: Fri, 27 Apr 90 06:10:31 PDT
From: Terence_Donahue
To: tdonahue

Info file make-info, produced by Makeinfo, -*- Text -*- from input
file make.texinfo.

This file documents the GNU Make utility.

Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled ``GNU General Public License'' is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translations of the section
entitled ``GNU General Public License'' must be approved for accuracy
by the Foundation.



File: make-info,  Node: Variables,  Next: Conditionals,  Prev: Commands,  Up: Top

How to Use Variables
********************

A "variable" is a name defined within `make' to represent a string of
text, called the variable's "value".  These values can be substituted
by explicit request into targets, dependencies, commands and other
parts of the makefile.

Variables can represent lists of file names, options to pass to
compilers, programs to run, directories to look in for source files,
directories to write output in, or anything else you can imagine.

A variable name may be any sequence characters not containing `:',
`#', `=', or leading or trailing whitespace.  However, variable names
containing characters other than letters, numbers and underscores
should be avoided, as they may be given special meanings in the
future, and they are not passed through the environment to a
sub-`make' (*note Variables/Recursion::.).

It is traditional to use upper case letters in variable names, but we
recommend using lower case letters for variable names that serve
internal purposes in the makefile, and reserving upper case for
parameters that control implicit rules or for parameters that the
user should override with command options (*note Overriding::.).

* Menu:

* Reference::   How to use the value of a variable.
* Flavors::     Variables come in two flavors.
* Advanced::    Advanced features for referencing a variable.
* Values::      All the ways variables get their values.
* Setting::     How to set a variable in the makefile.
* Override Directive:: Setting a variable in the makefile
                 even if the user has set it with a command argument.
* Defining::    An alternate way to set a variable to a verbatim string.
* Environment:: Variable values can come from the environment.

 

File: make-info,  Node: Reference,  Next: Flavors,  Prev: Variables,  Up: Variables

Basics of Variable References
=============================

To substitute a variable's value, write a dollar sign followed by the
name of the variable in parentheses or braces: either `$(foo)' or
`${foo}' is a valid reference to the variable `foo'.  This special
significance of `$' is why you must write `$$' to have the effect of
a single dollar sign in a file name or command.

Variable references can be used in any context: targets,
dependencies, commands, most directives, and new variable values. 
Here is a common kind of example, where a variable holds the names of
all the object files in a program:

     objects = program.o foo.o utils.o
     program : $(objects)
             cc -o program $(objects)
     
     $(objects) : defs.h

Variable references work by strict textual substitution.  Thus, the
rule

     foo = c
     prog.o : prog.c
             $(foo)$(foo) prog.c

could be used to compile a C program `prog.c'.  Since spaces around
the variable value are ignored in variable assignments, the value of
`foo' is precisely `c'.  (Don't actually write your makefiles this
way!)

A dollar sign followed by a character other than a dollar sign,
open-parenthesis or open-brace treats that single character as the
variable name.  Thus, you could reference the variable `x' with `$x'.
However, this practice is strongly discouraged, except in the case of
the automatic variables (*note Automatic::.).



File: make-info,  Node: Flavors,  Next: Advanced,  Prev: Reference,  Up: Variables

The Two Flavors of Variables
============================

There are two ways that a variables in GNU `make' can have a value;
we call them two "flavors" of variables.  The two flavors are
distinguished in how they are defined and in what they do when
expanded.

The first flavor of variable is a "recursively expanded" variable. 
Variables of this sort are defined by lines using `=' (*note
Setting::.).  The value you specify is installed verbatim; if it
contains references to other variables, these references are expanded
whenever this variable is substituted (in the course of expanding
some other string).  When this happens, it is called "recursive
expansion".

For example,

     foo = $(bar)
     bar = $(ugh)
     ugh = Huh?
     
     all:;echo $(foo)

will echo `Huh?': `$(foo)' expands to `$(bar)' which expands to
`$(ugh)' which finally expands to `Huh?'.

This flavor of variable is the only sort supported by other versions
of `make'.  It has its advantages and its disadvantages.  An
advantage (most would say) is that:

     CFLAGS = $(include_dirs) -O
     include_dirs = -Ifoo -Ibar

will do what was intended: when `CFLAGS' is expanded in a command, it
will expand to `-Ifoo -Ibar -O'.  A major disadvantage is that you
can't append something on the end of a variable, as in

     CFLAGS = $(CFLAGS) -O

because it will cause an infinite loop in the variable expansion. 
(Actually `make' detects the infinite loop and reports an error.)

Another disadvantage is that any functions (*note Functions::.)
referenced in the definition will be executed every time the variable
is expanded.  This makes `make' run slower; worse, it causes the
`wildcard' and `shell' functions to give unpredictable results
because you cannot easily control when they are called, or even how
many times.

To avoid all the problems and inconveniences of recursively expanded
variables, there is another flavor: "simply expanded" variables.

Simply expanded variables are defined by lines using `:=' (*note
Setting::.).  The value of a simply expanded variable is scanned once
and for all, expanding any references to other variables and
functions, when the variable is defined.  The actual value of the
simply expanded variable is the result of expanding the text that you
write.  It does not contain any references to other variables; it
contains their values *as of the time this variable was defined*. 
Therefore,

     x := foo
     y := $(x) bar
     x := later

is equivalent to

     y := foo bar
     x := later

When a simply expanded variable is referenced, its value is
substituted verbatim.

Simply expanded variables generally make complicated makefile
programming more predictable because they work like variables in most
programming languages.  They allow you to redefine a variable using
its own value (or its value processed in some way by one of the
expansion functions) and to use the expansion functions much more
efficiently (*note Functions::.).

You can also use them to introduce controlled leading or trailing
spaces into variable values.  Such spaces are discarded from your
input before substitution of variable references and function calls;
this means you can include leading or trailing spaces in a variable
value by protecting them with variable references, like this:

     nullstring :=
     space := $(nullstring) $(nullstring)

Here the value of the variable `space' is precisely one space.



File: make-info,  Node: Advanced,  Next: Values,  Prev: Flavors,  Up: Variables

Advanced Features for Reference to Variables
============================================

This section describes some advanced features you can use to
reference variables in more flexible ways.

* Menu:

* Substitution Refs::   Referencing a variable with substitutions on the value.
* Computed Names::      Computing the name of the variable to refer to.

 

File: make-info,  Node: Substitution Refs,  Next: Computed Names,  Prev: Advanced,  Up: Advanced

Substitution References
-----------------------

A "substitution reference" substitutes the value of a variable with
alterations that you specify.  It has the form `$(VAR:A=B)' (or
`${VAR:A=B}') and its meaning is to take the value of the variable
VAR, replace every A at the end of a word with B in that value, and
substitute the resulting string.

When we say ``at the end of a word'', we mean that A must appear
either followed by whitespace or at the end of the value in order to
be replaced; other occurrences of A in the value are unaltered.  For
example:

     foo := a.o b.o c.o
     bar := $(foo:.o=.c)

sets `bar' to `a.c b.c c.c'.  *Note Setting::.

A substitution reference is actually an abbreviation for use of the
`patsubst' expansion function (*note Text Functions::.).  We provide
substitution references as well as `patsubst' for compatibility with
other implementations of `make'.

Another type of substitution reference lets you use the full power of
the `patsubst' function.  It has the same form `$(VAR:A=B)' described
above, except that now A must contain a single `%' character.  This
case is equivalent to `$(patsubst A,B,$(VAR))'.  *Note Text
Functions::, for a description of the `patsubst' function.  For
example:

     foo := a.o b.o c.o
     bar := $(foo:%.o=%.c)

sets `bar' to `a.c b.c c.c'.



File: make-info,  Node: Computed Names,  Prev: Substitution Refs,  Up: Advanced

Computed Variable Names
-----------------------

Computed variable names are a complicated concept needed only for
sophisticated makefile programming.  For most purposes you need not
consider about them, except to know that making a variable with a
dollar sign in its name might have strange results.  However, if you
are the type that wants to understand everything, or you are actually
interested in what they do, read on.

Variables may be referenced inside the name of a variable.  This is
called a "computed variable name" or a "nested variable reference". 
For example,

     x = y
     y = z
     a := $($(x))

defines `a' as `z': the `$(x)' inside `$($(x))' expands to `y', so
`$($(x))' expands to `$(y)' which in turn expands to `z'.  Here the
name of the variable to reference is not stated explicitly; it is
computed by expansion of `$(x)'.  The reference `$(x)' here is nested
within the outer variable reference.

The previous example shows two levels of nesting, but any number of
levels is possible.  For example, here are three levels:

     x = y
     y = z
     z = u
     a := $($($(x)))

Here the innermost `$(x)' expands to `y', so `$($(x))' expands to
`$(y)' which in turn expands to `z'; now we have `$(z)', which
becomes `u'.

References to recursively-expanded variables within a variable name
are reexpanded in the usual fashion.  For example:

     x = $(y)
     y = z
     z = Hello
     a := $($(x))

defines `a' as `Hello': `$($(x))' becomes `$($(y))' which becomes
`$(z)' which becomes `Hello'.

Nested variable references can also contain modified references and
function invocations (*note Functions::.), just like any other
reference.  For example, using the `subst' function (*note Text
Functions::.):

     x = variable1
     variable2 := Hello
     y = $(subst 1,2,$(x))
     z = y
     a := $($($(z)))

eventually defines `a' as `Hello'.  It is doubtful that anyone would
ever want to write a nested reference as convoluted as this one, but
it works: `$($($(z)))' expands to `$($(y))' which becomes `$($(subst
1,2,$(x)))'.  This gets the value `variable1' from `x' and changes it
by substitution to `variable2', so that the entire string becomes
`$(variable2)', a simple variable reference whose value is `Hello'.

A computed variable name need not consist entirely of a single
variable reference.  It can contain several variable references, as
well as some invariant text.  For example,

     a_dirs := dira dirb
     1_dirs := dir1 dir2
     
     a_files := filea fileb
     1_files := file1 file2
     
     ifeq "$(use_a)" "yes"
     a1 := a
     else
     a1 := 1
     endif
     
     ifeq "$(use_dirs)" "yes"
     df := dirs
     else
     df := files
     endif
     
     dirs := $($(a1)_$(df))

will give `dirs' the same value as `a_dirs', `1_dirs', `a_files' or
`1_files' depending on the settings of `use_a' and `use_dirs'.

Computed variable names can also be used in substitution references:

     a_objects := a.o b.o c.o
     1_objects := 1.o 2.o 3.o
     
     sources := $($(a1)_object:.o=.c)

defines `sources' as either `a.c b.c c.c' or `1.c 2.c 3.c', depending
on the value of `a1'.

The only restriction on this sort of use of nested variable
references is that they cannot specify part of the name of a function
to be called.  This is because the test for a recognized function
name is done before the expansion of nested references.  For example,

     ifdef do_sort
     func := sort
     else
     func := strip
     endif
     
     bar := a d b g q c
     
     foo := $($(func) $(bar))

attempts to give `foo' the value of the variable `sort a d b g q c'
or `strip a d b g q c', rather than giving `a d b g q c' as the
argument to either the `sort' or the `strip' function.  This
restriction could be removed in the future if that change is shown to
be a good idea.

Note that "nested variable references" are quite different from
"recursively expanded variables" (*note Flavors::.), though both are
used together in complex ways when doing makefile programming.



File: make-info,  Node: Values,  Next: Setting,  Prev: Advanced,  Up: Variables

How Variables Get Their Values
==============================

Variables can get values in several different ways:

   * You can specify an overriding value when you run `make'.  *Note
     Overriding::.

   * You can specify a value in the makefile, either with an
     assignment (*note Setting::.) or with a verbatim definition
     (*note Defining::.).

   * Values are inherited from the environment.  *Note Environment::.

   * Several "automatic" variables are given new values for each rule.
     Each of these has a single conventional use.  *Note Automatic::.

   * Several variables have constant initial values.  *Note Implicit
     Variables::.



File: make-info,  Node: Setting,  Next: Override Directive,  Prev: Values,  Up: Variables

Setting Variables
=================

To set a variable from the makefile, write a line starting with the
variable name followed by `=' or `:='.  Whatever follows the `=' or
`:=' on the line becomes the value.  For example,

     objects = main.o foo.o bar.o utils.o

defines a variable named `objects'.  Whitespace around the variable
name and after the `=' is ignored.

Variables defined with `=' are "recursively expanded" variables. 
Variables defined with `:=' are "simply expanded" variables; these
definitions can contain variable references which will be expanded
before the definition is made.  *Note Flavors::.

There is no limit on the length of the value of a variable except the
amount of swapping space on the computer.  When a variable definition
is long, it is a good idea to break it into several lines by
inserting backslash-newline at convenient places in the definition. 
This will not affect the functioning of `make', but it will make the
makefile easier to read.

Most variable names are considered to have the empty string as a
value if you have never set them.  Several variables have built-in
initial values that are not empty, but can be set by you in the usual
ways (*note Implicit Variables::.).  Several special variables are
set automatically to a new value for each rule; these are called the
"automatic" variables (*note Automatic::.).



File: make-info,  Node: Override Directive,  Next: Defining,  Prev: Setting,  Up: Variables

The `override' Directive
========================

If a variable has been set with a command argument (*note
Overriding::.), then ordinary assignments in the makefile are
ignored.  If you want to set the variable in the makefile even though
it was set with a command argument, you can use an `override'
directive, which is a line that looks like this:

     override VARIABLE = VALUE

or

     override VARIABLE := VALUE

The `override' directive was not invented for escalation in the war
between makefiles and command arguments.  It was invented so you can
alter and add to values that the user specifies with command arguments.

For example, suppose you always want the `-g' switch when you run the
C compiler, but you would like to allow the user to specify the other
switches with a command argument just as usual.  You could use this
`override' directive:

     override CFLAGS := $(CFLAGS) -g

You can also use `override' directives with `define' directives. 
This is done as you might expect:

     override define foo
     bar
     endef

*Note Defining::.



File: make-info,  Node: Defining,  Next: Environment,  Prev: Override Directive,  Up: Variables

Defining Variables Verbatim
===========================

Another way to set the value of a variable is to use the `define'
directive.  This directive has a different syntax which allows
newline characters to be included in the value, which is convenient
for defining canned sequences of commands (*note Sequences::.).

The `define' directive is followed on the same line by the name of
the variable and nothing more.  The value to give the variable
appears on the following lines.  The end of the value is marked by a
line containing just the word `endef'.  Aside from this difference in
syntax, `define' works just like `='; it creates a
recursively-expanded variable (*note Flavors::.).

     define two-lines
     echo foo
     echo $(bar)
     endef

The value in an ordinary assignment cannot contain a newline; but the
newlines that separate the lines of the value in a `define' become
part of the variable's value (except for the final newline which
precedes the `endef' and is not considered part of the value).

The previous example is functionally equivalent to this:

     two-lines = echo foo; echo $(bar)

since the shell will interpret the semicolon and the newline
identically.

If you want variable definitions made with `define' to take
precedence over command-line variable definitions, the `override'
directive can be used together with `define':

     override define two-lines
     foo
     $(bar)
     endef

*Note Override Directive::.



File: make-info,  Node: Environment,  Prev: Defining,  Up: Variables

Variables from the Environment
==============================

Variables in `make' can come from the environment with which `make'
is run.  Every environment variable that `make' sees when it starts
up is transformed into a `make' variable with the same name and
value.  But an explicit assignment in the makefile, or with a command
argument, overrides the environment.  (If the `-e' flag is specified,
then values from the environment override assignments in the makefile.
*Note Options::.  But this is not recommended practice.)

Thus, by setting the variable `CFLAGS' in your environment, you can
cause all C compilations in most makefiles to use the compiler
switches you prefer.  This is safe for variables with standard or
conventional meanings because you know that no makefile will use them
for other things.  (But this is not totally reliable; some makefiles
set `CFLAGS' explicitly and therefore are not affected by the value
in the environment.)

When `make' is invoked recursively, variables defined in the outer
invocation are automatically passed to inner invocations through the
environment (*note Recursion::.).  This is the main purpose of
turning environment variables into `make' variables, and it requires
no attention from you.

Other use of variables from the environment is not recommended.  It
is not wise for makefiles to depend for their functioning on
environment variables set up outside their control, since this would
cause different users to get different results from the same
makefile.  This is against the whole purpose of most makefiles.

Such problems would be especially likely with the variable `SHELL',
which is normally present in the environment to specify the user's
choice of interactive shell.  It would be very undesirable for this
choice to affect `make'.  So `make' ignores the environment value of
`SHELL' if the value of `MAKELEVEL' is zero (which is normally true
except in recursive invocations of `make').



File: make-info,  Node: Conditionals,  Next: Functions,  Prev: Variables,  Up: Top

Conditional Parts of Makefiles
******************************

A "conditional" causes part of a makefile to be obeyed or ignored
depending on the values of variables.  Conditionals can compare the
value of one variable with another, or the value of a variable with a
constant string.  Conditionals control what `make' actually ``sees''
in the makefile, so they *cannot* be used to control shell commands
at the time of execution.

* Menu:

* Example: Conditional Example.   An annotated example.
* Syntax: Conditional Syntax.     Precise rules for syntax of conditionals.
* Flags: Testing Flags.           Conditionals testing flags such as `-t'.

 

File: make-info,  Node: Conditional Example,  Next: Conditional Syntax,  Prev: Conditionals,  Up: Conditionals

Example of a Conditional
========================

This conditional tells `make' to use one set of libraries if the `CC'
variable is `gcc', and a different set of libraries otherwise.  It
works by controlling which of two command lines will be used as the
command for a rule.  The result is that `CC=gcc' as an argument to
`make' changes not only which compiler is used but also which
libraries are linked.

     libs_for_gcc = -lgnu
     normal_libs =
     
     foo: $(objects)
     ifeq ($(CC),gcc)
             $(CC) -o foo $(objects) $(libs_for_gcc)
     else
             $(CC) -o foo $(objects) $(normal_libs)
     endif

This conditional uses three directives: one `ifeq', one `else' and
one `endif'.

The `ifeq' directive begins the conditional, and specifies the
condition.  It contains two arguments, separated by a comma and
surrounded by parentheses.  Variable substitution is performed on
both arguments and then they are compared.  The lines of the makefile
following the `ifeq' are obeyed if the two arguments match; otherwise
they are ignored.

The `else' directive causes the following lines to be obeyed if the
previous conditional failed.  In the example above, this means that
the second alternative linking command is used whenever the first
alternative is not used.  It is optional to have an `else' in a
conditional.

The `endif' directive ends the conditional.  Every conditional must
end with an `endif'.  Unconditional makefile text follows.

Conditionals work at the textual level: the lines of the conditional
are treated as part of the makefile, or ignored, according to the
condition.  This is why the larger syntactic units of the makefile,
such as rules, may cross the beginning or the end of the conditional.

When the variable `CC' has the value `gcc', the above example has
this effect:

     foo: $(objects)
             $(CC) -o foo $(objects) $(libs_for_gcc)

When the variable `CC' has any other value, the effect is this:

     foo: $(objects)
             $(CC) -o foo $(objects) $(normal_libs)

Equivalent results can be obtained in another way by conditionalizing
a variable assignment and then using the variable unconditionally:

     libs_for_gcc = -lgnu
     normal_libs =
     
     ifeq ($(CC),gcc)
       libs=$(libs_for_gcc)
     else
       libs=$(normal_libs)
     endif
     
     foo: $(objects)
             $(CC) -o foo $(objects) $(libs)



File: make-info,  Node: Conditional Syntax,  Next: Testing Flags,  Prev: Conditional Example,  Up: Conditionals

Syntax of Conditionals
======================

The syntax of a simple conditional with no `else' is as follows:

     CONDITIONAL-DIRECTIVE
     TEXT-IF-TRUE
     endif

The TEXT-IF-TRUE may be any lines of text, to be considered as part
of the makefile if the condition is true.  If the condition is false,
no text is used instead.

The syntax of a complex conditional is as follows:

     CONDITIONAL-DIRECTIVE
     TEXT-IF-TRUE
     else
     TEXT-IF-FALSE
     endif

If the condition is true, TEXT-IF-TRUE is used; otherwise,
TEXT-IF-FALSE is used instead.  The TEXT-IF-FALSE can be any number
of lines of text.

The syntax of the CONDITIONAL-DIRECTIVE is the same whether the
conditional is simple or complex.  There are four different
directives that test different conditions.  Here is a table of them:

`ifeq (ARG1, ARG2)'
`ifeq 'ARG1' 'ARG2''
`ifeq "ARG1" "ARG2"'
`ifeq "ARG1" 'ARG2''
`ifeq 'ARG1' "ARG2"'
     Expand all variable references in ARG1 and ARG2 and compare
     them.  If they are identical, the TEXT-IF-TRUE is effective;
     otherwise, the TEXT-IF-FALSE, if any, is effective.

`ifneq (ARG1, ARG2)'
`ifneq 'ARG1' 'ARG2''
`ifneq "ARG1" "ARG2"'
`ifneq "ARG1" 'ARG2''
`ifneq 'ARG1' "ARG2"'
     Expand all variable references in ARG1 and ARG2 and compare
     them.  If they are different, the TEXT-IF-TRUE is effective;
     otherwise, the TEXT-IF-FALSE, if any, is effective.

`ifdef VARIABLE-NAME'
     If the variable VARIABLE-NAME has a non-empty value, the
     TEXT-IF-TRUE is effective; otherwise, the TEXT-IF-FALSE, if any,
     is effective.  Variables that have never been defined have an
     empty value.

`ifndef VARIABLE-NAME'
     If the variable VARIABLE-NAME has an empty value, the
     TEXT-IF-TRUE is effective; otherwise, the TEXT-IF-FALSE, if any,
     is effective.

Extra spaces are allowed and ignored at the beginning of the
conditional directive line, but a tab is not allowed.  (If the line
begins with a tab, it will be considered a command for a rule.) 
Aside from this, extra spaces or tabs may be inserted with no effect
anywhere except within the directive name or within an argument.  A
comment starting with `#' may appear at the end of the line.

The other two directives that play a part in a conditional are `else'
and `endif'.  Each of these directives is written as one word, with
no arguments.  Extra spaces are allowed and ignored at the beginning
of the line, and spaces or tabs at the end.  A comment starting with
`#' may appear at the end of the line.

Conditionals work at the textual level.  The lines of the
TEXT-IF-TRUE are read as part of the makefile if the condition is
true; if the condition is false, those lines are ignored completely. 
It follows that syntactic units of the makefile, such as rules, may
safely be split across the beginning or the end of the conditional.

To prevent intolerable confusion, it is not permitted to start a
conditional in one makefile and end it in another.  However, you may
write an `include' directive within a conditional, provided you do
not attempt to terminate the conditional inside the included file.



File: make-info,  Node: Testing Flags,  Prev: Conditional Syntax,  Up: Conditionals

Conditionals that Test Flags
============================

You can write a conditional that tests `make' command flags such as
`-t' by using the variable `MAKEFLAGS' together with the `findstring'
function.  This is useful when `touch' is not enough to make a file
appear up to date.

The `findstring' function determines whether one string appears as a
substring of another.  If you want to test for the `-t' flag, use `t'
as the first string and the value of `MAKEFLAGS' as the other.

For example, here is how to arrange to use `ranlib -t' to finish
marking an archive file up to date:

     archive.a: ...
     ifneq (,$(findstring t,$(MAKEFLAGS)))
             @echo $(MAKE) > /dev/null
             touch archive.a
             ranlib -t archive.a
     else
             ranlib archive.a
     endif

The `echo' command does nothing when executed; but its presence, with
a reference to the variable `MAKE', marks the rule as ``recursive''
so that its commands will be executed despite use of the `-t' flag. 
*Note Recursion::.



File: make-info,  Node: Functions,  Next: Running,  Prev: Conditionals,  Up: Top

Functions for Transforming Text
*******************************

"Functions" allow you to do text processing in the makefile to
compute the files to operate on or the commands to use.  You use a
function in a "function call", where you give the name of the
function and some text (the "arguments") for the function to operate
on.  The result of the function's processing is substituted into the
makefile at the point of the call, just as a variable might be
substituted.

* Menu:

* Syntax of Functions:: How to write a function call.
* Text Functions::      General-purpose text manipulation functions.
* Filename Functions::  Functions for manipulating file names.
* Foreach Function::    Repeat some text with controlled variation.
* Origin Function::     Find where a variable got its value.
* Shell Function::      Substitute the output of a shell command.

 

File: make-info,  Node: Syntax of Functions,  Next: Text Functions,  Prev: Functions,  Up: Functions

Function Call Syntax
====================

A function call resembles a variable reference.  It looks like this:

     $(FUNCTION ARGUMENTS)

or like this:

     ${FUNCTION ARGUMENTS}

Here FUNCTION is a function name; one of a short list of names that
are part of `make'.  There is no provision for defining new functions.

The ARGUMENTS are the arguments of the function.  They are separated
from the function name by one or more spaces and/or tabs, and if
there is more than one argument they are separated by commas.  Such
whitespace and commas are not part of any argument's value.  The
delimiters which you use to surround the function call, whether
parentheses or braces, can appear in an argument only in matching
pairs; the other kind of delimiters may appear singly.  If the
arguments themselves contain other function calls or variable
references, it is wisest to use the same kind of delimiters for all
the references; in other words, write `$(subst a,b,$(x))', not
`$(subst a,b,${x})'.  This is both because it is clearer, and because
only one type of delimiters is matched to find the end of the
reference.  Thus in `$(subst a,b,${subst c,d,${x}})' doesn't work
because the second `subst' function invocation ends at the first `}',
not the second.

The text written for each argument is processed by substitution of
variables and function calls to produce the argument value, which is
the text on which the function acts.  The substitution is done in the
order in which the arguments appear.

Commas and unmatched parentheses or braces cannot appear in the text
of an argument as written; leading spaces cannot appear in the text
of the first argument as written.  These characters can be put into
the argument value by variable substitution.  First define variables
`comma' and `space' whose values are isolated comma and space
characters, then substitute those variables where such characters are
wanted, like this:

     comma:= ,
     space:= $(empty) $(empty)
     foo:= a b c
     bar:= $(subst $(space),$(comma),$(foo))
     # bar is now `a,b,c'.

 Here the `subst' function replaces each space with a comma, through
the value of `foo', and substitutes the result.



File: make-info,  Node: Text Functions,  Next: Filename Functions,  Prev: Syntax of Functions,  Up: Functions

Functions for String Substitution and Analysis
==============================================

Here are some functions that operate on strings:

`$(subst FROM,TO,TEXT)'
     Performs a textual replacement on the text TEXT: each occurrence
     of FROM is replaced by TO.  The result is substituted for the
     function call.  For example,

          $(subst ee,EE,feet on the street)

     substitutes the string `fEEt on the strEEt'.

`$(patsubst PATTERN,REPLACEMENT,TEXT)'
     Finds whitespace-separated words in TEXT that match PATTERN and
     replaces them with REPLACEMENT.  Here PATTERN may contain a `%'
     which acts as a wildcard, matching any number of any characters
     within a word.  If REPLACEMENT also contains a `%', the `%' is
     replaced by the text that matched the `%' in PATTERN.

     `%' characters in `patsubst' function invocations can be quoted
     with preceding backslashes (`\').  Backslashes that would
     otherwise quote `%' characters can be quoted with more
     backslashes.  Backslashes that quote `%' characters or other
     backslashes are removed from the pattern before it is compared
     file names or has a stem substituted into it.  Backslashes that
     are not in danger of quoting `%' characters go unmolested.  For
     example, the pattern `the\%weird\\%pattern\\' has `the%weird\'
     preceding the operative `%' character, and `pattern\\' following
     it.  The final two backslashes are left alone because they can't
     affect any `%' character.

     Whitespace between words is folded into single space characters;
     leading and trailing whitespace is discarded.

     For example,

          $(patsubst %.c,%.o,x.c.c bar.c)

     produces the value `x.c.o bar.o'.

`$(strip STRING)'
     Removes leading and trailing whitespace from STRING and replaces
     each internal sequence of one or more whitespace characters with
     a single space.  Thus, `$(strip a b  c )' results in `a b c'.

`$(findstring FIND,IN)'
     Searches IN for an occurrence of FIND.  If it occurs, the value
     is FIND; otherwise, the value is empty.  You can use this
     function in a conditional to test for the presence of a specific
     substring in a given string.  Thus, the two examples,

          $(findstring a,a b c)
          $(findstring a,b c)

     produce the values `a' and `', respectively.  *Note Testing
     Flags::, for a practical application of `findstring'.

`$(filter PATTERN,TEXT)'
     Removes all whitespace-separated words in TEXT that do *not*
     match PATTERN, returning only matching words.  The pattern is
     written using `%', just like the patterns used in `patsubst'
     function above.

     The `filter' function can be used to separate out different
     types of strings (such as filenames) in a variable.  For example:

          sources := foo.c bar.c ugh.h
          foo: $(sources)
                  cc $(filter %.c,$(sources)) -o foo

     says that `foo' depends of `foo.c', `bar.c' and `ugh.h' but only
     `foo.c' and `bar.c' should be specified in the command to the
     compiler.

`$(filter-out PATTERN,TEXT)'
     Removes all whitespace-separated words in TEXT that *do* match
     PATTERN, returning only the words that match.  This is the exact
     opposite of the `filter' function.

`$(sort LIST)'
     Sorts the words of LIST in lexical order, removing duplicate
     words.  The output is a list of words separated by single spaces.
     Thus,

          $(sort foo bar lose)

     returns the value `bar foo lose'.

Here is a realistic example of the use of `subst' and `patsubst'. 
Suppose that a makefile uses the `VPATH' variable to specify a list
of directories that `make' should search for dependency files.  This
example shows how to tell the C compiler to search for header files
in the same list of directories.

The value of `VPATH' is a list of directories separated by colons,
such as `src:../headers'.  First, the `subst' function is used to
change the colons to spaces:

     $(subst :, ,$(VPATH))

This produces `src ../headers'.  Then `patsubst' is used to turn each
directory name into a `-I' flag.  These can be added to the value of
the variable `CFLAGS', which is passed automatically to the C
compiler, like this:

     override CFLAGS:= $(CFLAGS) $(patsubst %,-I%,$(subst :, ,$(VPATH)))

The effect is to append the text `-Isrc -I../headers' to the
previously given value of `CFLAGS'.  The `override' directive is used
so that the new value is assigned even if the previous value of
`CFLAGS' was specified with a command argument (*note Override
Directive::.).

The function `strip' can be very useful when used in conjunction with
conditionals.  When comparing something with the null string `""'
using `ifeq' or `ifneq', you usually want a string of just whitespace
to match the null string.  Thus,

     .PHONY: all
     ifneq   "$(needs_made)" ""
     all: $(needs_made)
     else
     all:;@echo 'Nothing to make!'
     endif

might fail to have the desired results.  Replacing the variable
reference `"$(needs_made)"' with the function call `"$(strip
$(needs_made))"' in the `ifneq' directive would make it more robust.



File: make-info,  Node: Filename Functions,  Next: Foreach Function,  Prev: Text Functions,  Up: Functions

Functions for File Names
========================

Several of the built-in expansion functions relate specifically to
taking apart file names or lists of file names.

Each of the following functions performs a specific transformation on
a file name.  The argument of the function is regarded as a series of
file names, separated by whitespace.  (Leading and trailing
whitespace is ignored.)  Each file name in the series is transformed
in the same way and the results are concatenated with single spaces
between them.

`$(dir NAMES)'
     Extracts the directory-part of each file name in NAMES.  The
     directory-part of the file name is everything up through (and
     including) the last slash in it.  If the file name contains no
     slash, the directory part is the string `./'.  For example,

          $(dir src/foo.c hacks)

     produces the result `src/ ./'.

`$(notdir NAMES)'
     Extracts all but the directory-part of each file name in NAMES. 
     If the file name contains no slash, it is left unchanged. 
     Otherwise, everything through the last slash is removed from it.

     A file name that ends with a slash becomes an empty string. 
     This is unfortunate, because it means that the result does not
     always have the same number of whitespace-separated file names
     as the argument had; but we do not see any other valid
     alternative.

     For example,

          $(notdir src/foo.c hacks)

     produces the result `foo.c hacks'.

`$(suffix NAMES)'
     Extracts the suffix of each file name in NAMES.  If the file
     name contains a period, the suffix is everything starting with
     the last period.  Otherwise, the suffix is the empty string. 
     This frequently means that the result will be empty when NAMES
     is not, and if NAMES contains multiple file names, the result
     may contain fewer file names.

     For example,

          $(suffix src/foo.c hacks)

     produces the result `.c'.

`$(basename NAMES)'
     Extracts all but the suffix of each file name in NAMES.  If the
     file name contains a period, the basename is everything starting
     up to (and not including) the last period.  Otherwise, the
     basename is the entire file name.  For example,

          $(basename src/foo.c hacks)

     produces the result `src/foo hacks'.

`$(addsuffix SUFFIX,NAMES)'
     The argument NAMES is regarded as a series of names, separated
     by whitespace; SUFFIX is used as a unit.  The value of SUFFIX is
     appended to the end of each individual name and the resulting
     larger names are concatenated with single spaces between them. 
     For example,

          $(addsuffix .c,foo bar)

     produces the result `foo.c bar.c'.

`$(addprefix PREFIX,NAMES)'
     The argument NAMES is regarded as a series of names, separated
     by whitespace; PREFIX is used as a unit.  The value of PREFIX is
     appended to the front of each individual name and the resulting
     larger names are concatenated with single spaces between them. 
     For example,

          $(addprefix src/,foo bar)

     produces the result `src/foo src/bar'.

`$(join LIST1,LIST2)'
     Concatenates the two arguments word by word: the two first words
     (one from each argument) concatenated form the first word of the
     result, the two second words form the second word of the result,
     and so on.  So the Nth word of the result comes from the Nth
     word of each argument.  If one argument has more words that the
     other, the extra words are copied unchanged into the result.

     For example, `$(join a b,.c .o)' produces `a.c b.o'.

     Whitespace between the words in the lists is not preserved; it
     is replaced with a single space.

     This function can merge the results of the `dir' and `notdir'
     functions, to produce the original list of files which was given
     to those two functions.

`$(word N,TEXT)'
     Returns the Nth word of TEXT.  The legitimate values of N start
     from 1.  If N is bigger than the number of words in TEXT, the
     value is empty.  For example,

          $(word 2, foo bar baz)

     returns `bar'.

`$(words TEXT)'
     Returns the number of words in TEXT.  Thus, `$(word $(words
     TEXT),TEXT)' is the last word of TEXT.

`$(firstword NAMES)'
     The argument NAMES is regarded as a series of names, separated
     by whitespace.  The value is the first name in the series.  The
     rest of the names are ignored.  For example,

          $(firstword foo bar)

     produces the result `foo'.  Although `$(firstword TEXT)' is the
     same as `$(word 1,TEXT)', the `firstword' function is retained
     for its simplicity.

`$(wildcard PATTERN)'
     The argument PATTERN is a file name pattern, typically
     containing wildcard characters.  The result of `wildcard' is a
     space-separated list of the names of existing files that match
     the pattern.

     Wildcards are expanded automatically in rules.  *Note Wildcards::.
     But they are not normally expanded when a variable is set, or
     inside the arguments of other functions.  Those occasions are
     when the `wildcard' function is useful.



File: make-info,  Node: Foreach Function,  Next: Origin Function,  Prev: Filename Functions,  Up: Functions

The `foreach' Function
======================

The `foreach' function is very different from other functions.  It
causes one piece of text to be used repeatedly, each time with a
different substitution performed on it.  It resembles the `for'
command in the shell `sh' and the `foreach' command in the C-shell
`csh'.

The syntax of the `foreach' function is:

     $(foreach VAR,LIST,TEXT)

The first two arguments, VAR and LIST, are expanded before anything
else is done; note that the last argument, TEXT, is *not* expanded at
the same time.  Then for each word of the expanded value of LIST, the
variable named by the expanded value of VAR is set to that word, and
TEXT is expanded.  Presumably TEXT contains references to that
variable, so its expansion will be different each time.

The result is that TEXT is expanded as many times as there are
whitespace-separated words in LIST.  The multiple expansions of TEXT
are concatenated, with spaces between them, to make the result of
`foreach'.

This simple example sets the variable `files' to the list of all
files in the directories in the list `dirs':

     dirs := a b c d
     files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))

Here TEXT is `$(wildcard $(dir)/*)'.  The first repetition finds the
value `a' for `dir', so it produces the same result as `$(wildcard
a/*)'; the second repetition produces the result of `$(wildcard
b/*)'; and the third, that of `$(wildcard c/*)'.

This example has the same result (except for setting `find_files',
`dirs' and `dir') as the following example:

     files := $(wildcard a/* b/* c/* d/*)

When TEXT is complicated, you can improve readability by giving it a
name, with an additional variable:

     find_files = $(wildcard $(dir)/*)
     dirs := a b c d
     files := $(foreach dir,$(dirs),$(find_files))

Here we use the variable `find_files' this way.  We use plain `=' to
define a recursively-expanding variable, so that its value contains
an actual function call to be reexpanded under the control of
`foreach'; a simply-expanded variable would not do, since `wildcard'
would be called only once at the time of defining `find_files'.

The `foreach' function has no permanent effect on the variable VAR;
its value and flavor after the `foreach' function call are the same
as they were beforehand.  The other values which are taken from LIST
are in effect only temporarily, during the execution of `foreach'. 
The variable VAR is a simply-expanded variable during the execution
of `foreach'.  If VAR was undefined before the `foreach' function
call, it is undefined after the call.  *Note Flavors::.

You must take care when using complex variable expressions that
result in variable names because many strange things are valid
variable names, but are probably not what you intended.  For example,

     files := $(foreach Es escrito en espanol!,b c ch,$(find_files))

might be useful if the value of `find_files' references the variable
whose name is `Es escrito en espanol!' (es un nombre bastante largo,
que no?), but it is more likely to be a mistake.



File: make-info,  Node: Origin Function,  Next: Shell Function,  Prev: Foreach Function,  Up: Functions

The `origin' Function
=====================

The `origin' function is unlike most other functions in that it does
not operate on the values of variables; it tells you something
*about* a variable.  Specifically, it tells you where it came from.

The syntax of the `origin' function is:

     $(origin VARIABLE)

Note that VARIABLE is the *name* of a variable to inquire about; not
a *reference* to that variable.  Therefore you would not normally use
a `$' or parentheses when writing it.  (You can, however, use a
variable reference in the name if you want the name not to be a
constant.)

The result of this function is a string telling you how the variable
VARIABLE was defined:

`undefined'
     if VARIABLE was never defined.

`default'
     if VARIABLE has a default definition, as is usual with `CC' and
     so on.  *Note Implicit Variables::.  Note that if you have
     redefined a default variable, the `origin' function will return
     the origin of the later definition.

`environment'
     if VARIABLE was defined as an environment variable and the `-e'
     option is *not* turned on (*note Options::.).

`environment override'
     if VARIABLE was defined as an environment variable and the `-e'
     option *is* turned on (*note Options::.).

`file'
     if VARIABLE was defined in a makefile.

`command line'
     if VARIABLE was defined on the command line.

`override'
     if VARIABLE was defined with an `override' directive in a
     makefile (*note Override Directive::.).

`automatic'
     if VARIABLE is an automatic variable defined for the execution
     of the commands for each rule.

This information is primarily useful (other than for your curiosity)
to determine if you want to believe the value of a variable.  For
example, suppose you have a makefile `foo' that includes another
makefile `bar'.  You want a variable `bletch' to be defined in `bar'
if you run the command `make -f bar', even if the environment
contains a definition of `bletch'.  However, if `foo' defined
`bletch' before including `bar', you don't want to override that
definition.  This could be done by using an `override' directive in
`foo', giving that definition precedence over the later definition in
`bar'; unfortunately, the `override' directive would also override
any command line definitions.  So, `bar' could include:

     ifdef bletch
     ifeq "$(origin bletch)" "environment"
     bletch = barf, gag, etc.
     endif
     endif

If `bletch' has been defined from the environment, this will redefine
it.

If you want to override a previous definition of `bletch' if it came
from the environment, even under `-e', you could instead write:

     ifneq "$(findstring environment,$(origin bletch))" ""
     bletch = barf, gag, etc.
     endif

Here the redefinition takes place if `$(origin bletch)' returns
either `environment' or `environment override'.



File: make-info,  Node: Shell Function,  Prev: Origin Function,  Up: Functions

The `shell' Function
====================

The `shell' function is unlike any other function except the
`wildcard' function (*note Wildcard Function::.) in that it
communicates with the world outside of `make'.

The `shell' function performs the same function that backquotes (``')
perform in most shells: it does "command expansion".  This means that
it takes an argument that is a shell command and returns the output
of the command.  The only processing `make' does on the result,
before substituting it into the surrounding text, is to convert
newlines to spaces.

The commands run by calls to the `shell' function are run when the
function calls are expanded.  In most cases, this is when the
makefile is read in.  The exception is that function calls in the
commands of the rules are expanded when the commands are run, and
this applies to `shell' function calls like all others.

Here are some examples of the use of the `shell' function:

     contents := $(shell cat foo)

sets `contents' to the contents of the file `foo', with a space
(rather than a newline) separating each line.

     files := $(shell echo *.c)

sets `files' to the expansion of `*.c'.  Unless `make' is using a
very strange shell, this has the same result as `$(wildcard *.c)'.



Date: Fri, 27 Apr 90 06:10:33 PDT
From: Terence_Donahue
To: tdonahue

Info file make-info, produced by Makeinfo, -*- Text -*- from input
file make.texinfo.

This file documents the GNU Make utility.

Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled ``GNU General Public License'' is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translations of the section
entitled ``GNU General Public License'' must be approved for accuracy
by the Foundation.



File: make-info,  Node: Running,  Next: Implicit,  Prev: Functions,  Up: Top

How to Run `make'
*****************

A makefile that says how to recompile a program can be used in more
than one way.  The simplest use is to recompile every file that is
out of date.  This is what `make' will do if run with no arguments.

But you might want to update only some of the files; you might want
to use a different compiler or different compiler options; you might
want just to find out which files are out of date without changing
them.

By specifying arguments when you run `make', you can do any of these
things or many others.

* Menu:

* Makefile Arguments::    Arguments to specify which makefile to use.

* Goals::                 Goal arguments specify which parts of the makefile
                           should be used.

* Instead of Execution::  Mode flags specify what kind of thing to do
                           with the commands in the makefile
                           other than simply execute them.

* Avoiding Compilation::  How to avoid recompiling certain files.

* Overriding::            Overriding a variable can specify an alternate
                           compiler, or alternate flags for the compiler,
                           or whatever else you program into the makefile.

* Testing::               How to proceed past some errors, to test compilation.

* Options::               Summary of all options `make' accepts.

 

File: make-info,  Node: Makefile Arguments,  Next: Goals,  Prev: Running,  Up: Running

Arguments to Specify the Makefile
=================================

The way to specify the name of the makefile is with the `-f' option. 
For example, `-f altmake' says to use the file `altmake' as the
makefile.

If you use the `-f' flag several times (each time with a following
argument), all the specified files are used jointly as makefiles.

If you do not use the `-f' flag, the default is to try `GNUmakefile',
`makefile', or `Makefile', in that order, and use the first of these
three which exists.  *Note Makefiles::.



File: make-info,  Node: Goals,  Next: Instead of Execution,  Prev: Makefile Arguments,  Up: Running

Arguments to Specify the Goals
==============================

The "goals" are the targets that `make' should strive ultimately to
update.  Other targets are updated as well if they appear as
dependencies of goals, or dependencies of dependencies of goals, etc.

By default, the goal is the first target in the makefile (not
counting targets that start with a period).  Therefore, makefiles are
usually written so that the first target is for compiling the entire
program or programs they describe.

You can specify a different goal or goals with arguments to `make'. 
Use the name of the goal as an argument.  If you specify several
goals, `make' processes each of them in turn, in the order you name
them.

Any target in the makefile may be specified as a goal (unless it
starts with `-' or contains an `=').  Even targets not in the
makefile may be specified, if `make' can find implicit rules that say
how to make them.

One use of specifying a goal is if you want to compile only a part of
the program, or only one of several programs.  Specify as a goal each
file that you wish to remake.  For example, consider a directory
containing several programs, with a makefile that starts like this:

     .PHONY: all
     all: size nm ld ar as

If you are working on the program `size', you might want to say `make
size' so that only the files of that program are recompiled.

Another use of specifying a goal is to make files that aren't
normally made.  For example, there may be a file of debugging output,
or a version of the program that is compiled specially for testing,
which has a rule in the makefile but isn't a dependency of the
default goal.

Another use of specifying a goal is to run the commands associated
with a phony target (*note Phony Targets::.) or empty target (*note
Empty Targets::.).  Many makefiles contain a phony target named
`clean' which deletes everything except source files.  Naturally,
this is done only if you request it explicitly with `make clean'. 
Here is a list of typical phony and empty target names:

`all'
     Make all the top-level targets the makefile knows about.

`clean'
     Delete all files that are normally created by running `make'.

`distclean'
`realclean'
`clobber'
     Any of these three might be defined to delete everything that
     would not be part of a standard distribution.  For example, this
     would delete configuration files or links that you would
     normally create as preparation for compilation, even if the
     makefile itself cannot create these files.

`install'
     Copy the executable file into a directory that users typically
     search for commands; copy any auxiliary files that the
     executable uses into the directories where it will look for them.

`print'
     Print listings of the source files that have changed.

`tar'
     Create a tar file of the source files.

`shar'
     Create a shell archive (shar file) of the source files.

`dist'
     Create a distribution file of the source files.  This might be a
     tar file, or a shar file, or a compressed version of one of the
     above, or even more than one of the above.



File: make-info,  Node: Instead of Execution,  Next: Avoiding Compilation,  Prev: Goals,  Up: Running

Instead of Executing the Commands
=================================

The makefile tells `make' how to tell whether a target is up to date,
and how to update each target.  But updating the targets is not
always what you want.  Certain options specify other activities for
`make'.

`-t'
     ``Touch''.  The activity is to mark the targets as up to date
     without actually changing them.  In other words, `make' pretends
     to compile the targets but does not really change their contents.

`-n'
     ``No-op''.  The activity is to print what commands would be used
     to make the targets up to date, but not actually execute them.

`-q'
     ``Question''.  The activity is to find out silently whether the
     targets are up to date already; but execute no commands in
     either case.  In other words, neither compilation nor output
     will occur.

`-W'
     ``What if''.  Each `-W' flag is followed by a file name.  The
     given files' modification times are recorded by `make' as being
     the present time, although the actual modification times remain
     the same.  When used in conjunction with the `-n' flag, the `-W'
     flag provides a way to see what would happen if you were to
     modify specific files.

With the `-n' flag, `make' prints without execution the commands that
it would normally execute.

With the `-t' flag, `make' ignores the commands in the rules and uses
(in effect) the command `touch' for each target that needs to be
remade.  The `touch' command is also printed, unless `-s' or
`.SILENT' is used.  For speed, `make' does not actually invoke the
program `touch'.  It does the work directly.

With the `-q' flag, `make' prints nothing and executes no commands,
but the exit status code it returns is zero if and only if the
targets to be considered are already up to date.

It is an error to use more than one of these three flags in the same
invocation of `make'.

The `-n', `-t', and `-q' options do not affect command lines that
begin with `+' characters or contain the strings `$(MAKE)' or
`${MAKE}'.  Note that only the line containing the `+' character or
the strings `$(MAKE)' or `${MAKE}' is run regardless of these
options.  Other lines in the same rule are not run unless they too
begin with `+' or contain `$(MAKE)' or `${MAKE}'.

The `-W' flag provides two features:

   * If you also use the `-n' or `-q' flag, you can see what `make'
     would do if you were to modify some files.

   * Without the `-n' or `-q' flag, when `make' is actually executing
     commands, the `-W' flag can direct `make' to act as if some
     files had been modified, without actually modifying the files.

Note that the options `-p' and `-v' allow you to obtain other
information about `make' or about the makefiles in use.  *Note
Options::.



File: make-info,  Node: Avoiding Compilation,  Next: Overriding,  Prev: Instead of Execution,  Up: Running

Avoiding Recompilation of Some Files
====================================

Sometimes you may have changed a source file but you don't want to
recompile all the files that depend on it.  For example, suppose you
add a macro or a declaration to a header file that many other files
depend on.  Being conservative, `make' assumes that any change in the
header file requires recompilation of all dependent files, but you
know that they don't need to be recompiled and you would rather not
waste the time waiting for them to compile.

If you anticipate the problem before changing the header file, you
can use the `-t' flag.  This flag tells `make' not to run the
commands in the rules, but rather to mark the target up to date by
changing its last-modification date.  You would follow this procedure:

  1. Use the command `make' to recompile the source files that really
     need recompilation.

  2. Make the changes in the header files.

  3. Use the command `make -t' to mark all the object files as up to
     date.  The next time you run `make', the changes in the header
     files will not cause any recompilation.

If you have already changed the header file at a time when some files
do need recompilation, it is too late to do this.  Instead, you can
use the `-o FILE' flag, which marks a specified file as ``old''
(*note Options::.).  This means that the file itself won't be remade,
and nothing else will be remade on its account.  Follow this procedure:

  1. Recompile the source files that need compilation for reasons
     independent of the particular header file, with `make -o
     HEADERFILE'.  If several header files are involved, use a
     separate `-o' option for each header file.

  2. Touch all the object files with `make -t'.



File: make-info,  Node: Overriding,  Next: Testing,  Prev: Avoiding Compilation,  Up: Running

Overriding Variables
====================

An argument that contains `=' specifies the value of a variable:
`V=X' sets the value of the variable V to X.  If you specify a value
in this way, all ordinary assignments of the same variable in the
makefile are ignored; we say they have been "overridden" by the
command line argument.

The most common way to use this facility is to pass extra flags to
compilers.  For example, in a properly written makefile, the variable
`CFLAGS' is included in each command that runs the C compiler, so a
file `foo.c' would be compiled something like this:

     cc -c $(CFLAGS) foo.c

Thus, whatever value you set for `CFLAGS' affects each compilation
that occurs.  The makefile probably specifies the usual value for
`CFLAGS', like this:

     CFLAGS=-g

Each time you run `make', you can override this value if you wish. 
For example, if you say `make CFLAGS='-g -O'', each C compilation
will be done with `cc -c -g -O'.  (This illustrates how you can
enclose spaces and other special characters in the value of a
variable when you override it.)

The variable `CFLAGS' is only one of many standard variables that
exist just so that you can change them this way.  *Note Implicit
Variables::, for a complete list.

You can also program the makefile to look at additional variables of
your own, giving the user the ability to control other aspects of how
the makefile works by changing the variables.

When you override a variable with a command argument, you can define
either a recursively-expanded variable or a simply-expanded variable.
The examples shown above make a recursively-expanded variable; to
make a simply-expanded variable, write `:=' instead of `='.  But,
unless you want to include a variable reference or function call in
the *value* that you specify, it makes no difference which kind of
variable you create.

There is one way that the makefile can change a variable that you
have overridden.  This is to use the `override' directive, which is a
line that looks like this: `override VARIABLE = VALUE'.  *Note
Override Directive::.



File: make-info,  Node: Testing,  Next: Options,  Prev: Overriding,  Up: Running

Testing the Compilation of a Program
====================================

Normally, when an error happens in executing a shell command, `make'
gives up immediately, returning a nonzero status.  No further
commands are executed for any target.  The error implies that the
goal cannot be correctly remade, and `make' reports this as soon as
it knows.

When you are compiling a program that you have just changed, this is
not what you want.  Instead, you would rather that `make' try
compiling every file that can be tried, to show you as many
compilation errors as possible.

On these occasions, you should use the `-k' flag.  This tells `make'
to continue to consider the other dependencies of the pending
targets, remaking them if necessary, before it gives up and returns
nonzero status.  For example, after an error in compiling one object
file, `make -k' will continue compiling other object files even
though it already knows that linking them will be impossible.  In
addition to continuing after failed shell commands, `make -k' will
continue as much as possible after discovering that it doesn't know
how to make a target or dependency file.  This will always cause an
error message, but without `-k', it is a fatal error.  *Note Options::.

The usual behavior of `make' assumes that your purpose is to get the
goals up to date; once `make' learns that this is impossible, it
might as well report the failure immediately.  The `-k' flag says
that the real purpose is to test as much as possible of the changes
made in the program, perhaps to find several independent problems so
that you can correct them all before the next attempt to compile. 
This is why Emacs's `M-x compile' command passes the `-k' flag by
default.



File: make-info,  Node: Options,  Prev: Testing,  Up: Running

Summary of Options
==================

Here is a table of all the options `make' understands:

`-b'
`-m'
     These options are ignored for compatibility with other versions
     of `make'.

`-C DIR'
     Change to directory DIR before reading the makefiles.  If
     multiple `-C' options are specified, each is interpreted
     relative to the previous one: `-C / -C etc' is equivalent to `-C
     /etc'.  This is typically used with recursive invocations of
     `make' (*note Recursion::.).

`-d'
     Print debugging information in addition to normal processing. 
     The debugging information says which files are being considered
     for remaking, which file-times are being compared and with what
     results, which files actually need to be remade, which implicit
     rules are considered and which are applied--everything
     interesting about how `make' decides what to do.

`-e'
     Give variables taken from the environment precedence over
     variables from makefiles.  *Note Environment::.

`-f FILE'
     Use file FILE as a makefile.  *Note Makefiles::.

`-i'
     Ignore all errors in commands executed to remake files.  *Note
     Errors::.

`-I DIR'
     Specifies a directory DIR to search for included makefiles. 
     *Note Include::.  If several `-I' options are used to specify
     several directories, the directories are searched in the order
     specified.  Unlike the arguments to other flags of `make',
     directories given with `-I' flags may come directly after the
     flag: `-IDIR' is allowed, as well as `-I DIR'.  This syntax is
     allowed for compatibility with the C preprocessor's `-I' flag.

`-j JOBS'
     Specifies the number of jobs (commands) to run simultaneously. 
     If there is more than one `-j' option, the last one is effective.
     *Note Execution::, for more information on how commands are run.

`-k'
     Continue as much as possible after an error.  While the target
     that failed, and those that depend on it, cannot be remade, the
     other dependencies of these targets can be processed all the same.
     *Note Testing::.

`-l LOAD'
`-l'
     Specifies that no new jobs (commands) should be started if there
     are others jobs running and the load average is at least LOAD (a
     floating-point number).  With no argument, removes a previous
     load limit.  *Note Parallel::.

`-n'
     Print the commands that would be executed, but do not execute
     them.  *Note Instead of Execution::.

`-o FILE'
     Do not remake the file FILE even if it is older than its
     dependencies, and do not remake anything on account of changes
     in FILE.  Essentially the file is treated as very old and its
     rules are ignored.  *Note Avoiding Compilation::.

`-p'
     Print the data base (rules and variable values) that results
     from reading the makefiles; then execute as usual or as
     otherwise specified.  This also prints the version information
     given by the `-v' switch (see below).  To print the data base
     without trying to remake any files, use `make -p -f /dev/null'.

`-q'
     ``Question mode''.  Do not run any commands, or print anything;
     just return an exit status that is zero if the specified targets
     are already up to date, nonzero otherwise.  *Note Instead of
     Execution::.

`-r'
     Eliminate use of the built-in implicit rules (*note Implicit::.).
     Also clear out the default list of suffixes for suffix rules
     (*note Suffix Rules::.).

`-s'
     Silent operation; do not print the commands as they are executed.
     *Note Echoing::.

`-S'
     Cancel the effect of the `-k' option.  This is never necessary
     except in a recursive `make' where `-k' might be inherited from
     the top-level `make' via `MAKEFLAGS' (*note Recursion::.) or if
     you set `-k' in `MAKEFLAGS' in your environment.

`-t'
     Touch files (mark them up to date without really changing them)
     instead of running their commands.  This is used to pretend that
     the commands were done, in order to fool future invocations of
     `make'.  *Note Instead of Execution::.

`-v'
     Print the version of the `make' program plus a copyright, a list
     of authors and a notice that there is no warranty.  After this
     information is printed, processing continues normally.  To get
     this information without doing anything else, use `make -v -f
     /dev/null'.

`-w'
     Print a message containing the working directory both before and
     after executing the makefile.  This may be useful for tracking
     down errors from complicated nests of recursive `make' commands.
     *Note Recursion::.

`-W FILE'
     Pretend that the target FILE has just been modified.  When used
     with the `-n' flag, this shows you what would happen if you were
     to modify that file.  Without `-n', it is almost the same as
     running a `touch' command on the given file before running
     `make', except that the modification time is changed only in the
     imagination of `make'.



File: make-info,  Node: Implicit,  Next: Archives,  Prev: Running,  Up: Top

Using Implicit Rules
********************

Certain standard ways of remaking target files are used very often. 
For example, one customary way to make an object file is from a C
source file using the C compiler, `cc'.

"Implicit rules" tell `make' how to use customary techniques so that
you don't have to specify them in detail when you want to use them. 
For example, there is an implicit rule for C compilation.  Implicit
rules work based on file names.  For example, C compilation typically
takes a `.c' file and makes a `.o' file.  So `make' applies the
implicit rule for C compilation when it sees this combination of
file-name endings.

A chain of implicit rules can apply in sequence; for example, `make'
will remake a `.o' file from a `.y' file by way of a `.c' file.

The built-in implicit rules use several variables in their commands
so that, by changing the values of the variables, you can change the
way the implicit rule works.  For example, the variable `CFLAGS'
controls the flags given to the C compiler by the implicit rule for C
compilation.

You can define your own implicit rules by writing "pattern rules".

* Menu:

* Using Implicit::       How to use an existing implicit rule
                          to get the commands for updating a file.

* Catalogue of Rules::   Catalogue of built-in implicit rules.

* Implicit Variables::   By changing certain variables, you can
                          change what the predefined implicit rules do.

* Chained Rules::        Using a chain of implicit rules.

* Pattern Rules::        Defining new implicit rules.

* Last Resort::          Defining commands for rules which can't find any.

* Suffix Rules::         The old-fashioned style of implicit rule.

* Search Algorithm::     Precise algorithm for applying implicit rules.

 

File: make-info,  Node: Using Implicit,  Next: Catalogue of Rules,  Prev: Implicit,  Up: Implicit

Using Implicit Rules
====================

To allow `make' to find a customary method for updating a target
file, all you have to do is refrain from specifying commands
yourself.  Either write a rule with no command lines, or don't write
a rule at all.  Then `make' will figure out which implicit rule to
use based on which kind of source file exists.

For example, suppose the makefile looks like this:

     foo : foo.o bar.o
             cc -o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)

Because you mention `foo.o' but do not give a rule for it, `make'
will automatically look for an implicit rule that tells how to update
it.  This happens whether or not the file `foo.o' currently exists.

If an implicit rule is found, it supplies both commands and one or
more dependencies (the source files).  You would want to write a rule
for `foo.o' with no command lines if you need to specify additional
dependencies, such as header files, that the implicit rule cannot
supply.

Each implicit rule has a target pattern and dependency patterns. 
There may be many implicit rules with the same target pattern.  For
example, numerous rules make `.o' files: one, from a `.c' file with
the C compiler; another, from a `.p' file with the Pascal compiler;
and so on.  The rule that actually applies is the one whose
dependencies exist or can be made.  So, if you have a file `foo.c',
`make' will run the C compiler; otherwise, if you have a file
`foo.p', `make' will run the Pascal compiler; and so on.

Of course, when you write the makefile, you know which implicit rule
you want `make' to use, and you know it will choose that one because
you know which possible dependency files are supposed to exist. 
*Note Catalogue of Rules::, for a catalogue of all the predefined
implicit rules.

Above, we said an implicit rule applies if the required dependencies
``exist or can be made''.  A file ``can be made'' if it is mentioned
explicitly in the makefile as a target or a dependency, or if an
implicit rule can be recursively found for how to make it.  When an
implicit dependency is the result of another implicit rule, we say
that "chaining" is occurring.  *Note Chained Rules::.

In general, `make' searches for an implicit rule for each target, and
for each double-colon rule, that has no commands.  A file that is
mentioned only as a dependency is considered a target whose rule
specifies nothing, so implicit rule search happens for it.  *Note
Search Algorithm::, for the details of how the search is done.

If you don't want an implicit rule to be used for a target that has
no commands, you can give that target empty commands by writing a
semicolon.  *Note Empty Commands::.



File: make-info,  Node: Catalogue of Rules,  Next: Implicit Variables,  Prev: Using Implicit,  Up: Implicit

Catalogue of Implicit Rules
===========================

Here is a catalogue of predefined implicit rules which are always
available unless the makefile explicitly overrides or cancels them. 
*Note Canceling Rules::, for information on canceling or overriding
an implicit rule.  The `-r' option cancels all predefined rules.

Not all of these rules will always be defined, even when the `-r'
option is not given.  Many of the predefined implicit rules are
implemented in `make' as suffix rules, so which ones will be defined
depends on the "suffix list" (the list of dependencies of the special
target `.SUFFIXES').  *Note Suffix Rules::.  The default suffix list
is: `.out', `.a', `.o', `.c', `.cc', `.p', `.f', `.F', `.r', `.e',
`.y', `.ye', `.yr', `.l', `.s', `.S', `.h', `.info', `.dvi', `.tex',
`.texinfo', `.cweb', `.web', `.sh', `.elc', `.el'. All of the
implicit rules described below whose dependencies have one of these
suffixes are actually suffix rules.  If you modify the suffix list,
the only predefined suffix rules in effect will be those named by one
or two of the suffixes that are on the list you specify; rules whose
suffixes fail to be on the list are disabled.

Compiling C programs
     `N.o' will be made automatically from `N.c' with a command of
     the form `$(CC) -c $(CPPFLAGS) $(CFLAGS)'.

Compiling C++ programs
     `N.o' will be made automatically from `N.cc' with a command of
     the form `$(C++) -c $(CPPFLAGS) $(C++FLAGS)'.  Although
     supported by the GNU C++ compiler, the suffix used by the AT&T
     C++ preprocessor, `.C', is not supported in `make' because we
     encourage the use of the preferred suffix for C++ files, `.cc'.

Compiling Pascal programs
     `N.o' will be made automatically from `N.p' with the command
     `$(PC) -c $(PFLAGS)'.

Compiling Fortran and Ratfor programs
     `N.o' will be made automatically from `N.r', `N.F' or `N.f' by
     running the Fortran compiler.  The precise command used is as
     follows:

    `.f'
          `$(FC) -c $(FFLAGS)'.

    `.F'
          `$(FC) -c $(FFLAGS) $(CPPFLAGS)'.

    `.r'
          `$(FC) -c $(FFLAGS) $(RFLAGS)'.

Preprocessing Fortran and Ratfor programs
     `N.f' will be made automatically from `N.r' or `N.F'.  This rule
     runs just the preprocessor to convert a Ratfor or preprocessable
     Fortran program into a strict Fortran program.  The precise
     command used is as follows:

    `.F'
          `$(FC) -F $(CPPFLAGS) $(FFLAGS)'.

    `.r'
          `$(FC) -F $(FFLAGS) $(RFLAGS)'.

Compiling Modula-2 programs
     `N.sym' will be made from `N.def' with a command of the form
     `$(M2C) $(M2FLAGS) $(DEFFLAGS)'.  `N.o' will be made from
     `N.mod' with a command of the form `$(M2C) $(M2FLAGS)
     $(MODFLAGS)'.

Assembling and preprocessing assembler programs
     `N.o' will be made automatically from `N.s' by running the
     assembler `as'.  The precise command used is `$(AS) $(ASFLAGS)'.

     `N.s' will be made automatically from `N.S' by running the C
     preprocessor `cpp'.  The precise command used is `$(CPP)
     $(CPPFLAGS)'.

Linking a single object file
     `N' will be made automatically from `N.o' by running the linker
     `ld' via the C compiler.  The precise command used is `$(CC)
     $(LDFLAGS) N.o $(LOADLIBES)'.

     This rule does the right thing for a simple program with only
     one source file.  It will also do the right thing if there are
     multiple object files (presumably coming from various other
     source files), the first of which has a name matching that of
     the executable file.  Thus,

          x: y.o z.o

     when `x.c', `y.c' and `z.c' all exist will execute:

          cc -c x.c -o x.o
          cc -c y.c -o y.o
          cc -c z.c -o z.o
          cc x.o y.o z.o -o x
          rm -f x.o
          rm -f y.o
          rm -f z.o

     In more complicated cases, such as when there is no object file
     whose name derives from the executable file name, you must write
     an explicit command for linking.

     Each kind of file automatically made into `.o' object files will
     be automatically linked by using the compiler (`$(CC)', `$(FC)'
     or `$(PC)'; the C compiler `$(CC)' is used to assemble `.s'
     files) without the `-c' option.  This could be done by using the
     `.o' object files as intermediates, but it is faster to do the
     compiling and linking in one step, so that's how it's done.

Yacc for C programs
     `N.c' will be made automatically from `N.y' by running Yacc with
     the command `$(YACC) $(YFLAGS)'.

Lex for C programs
     `N.c' will be made automatically from `N.l' by by running Lex. 
     The actual command is `$(LEX) $(LFLAGS)'.

Lex for Ratfor programs
     `N.r' will be made automatically from `N.l' by by running Lex. 
     The actual command is `$(LEX) $(LFLAGS)'.

     The convention of using the same suffix `.l' for all Lex files
     regardless of whether they produce C code or Ratfor code makes
     it impossible for `make' to determine automatically which of the
     two languages you are using in any particular case.  If `make'
     is called upon to remake an object file from a `.l' file, it
     must guess which compiler to use.  It will guess the C compiler,
     because that is more common.  If you are using Ratfor, make sure
     `make' knows this by mentioning `N.r' in the makefile.  Or, if
     you are using Ratfor exclusively, with no C files, remove `.c'
     from the list of implicit rule suffixes with:

          .SUFFIXES:
          .SUFFIXES: .r .f .l ...

Making Lint Libraries from C, Yacc, or Lex programs
     `N.ln' will be made from `N.c' with a command of the form
     `$(LINT) $(LINTFLAGS) $(CPPFLAGS) -i'.  The same command will be
     used on the C code produced from `N.y' or `N.l'.

TeX and Web
     `N.dvi' will be made from `N.tex' with the command `$(TEX)'. 
     `N.tex' will be made from `N.web' with `$(WEAVE)', or from
     `N.cweb' with `$(CWEAVE)'.  `N.p' will be made from `N.web' with
     `$(TANGLE)' and `N.c' will be made from `N.cweb' with
     `$(CTANGLE)'.

Texinfo and Info
     `N.dvi' will be made from `N.texinfo' using the `$(TEX)' and
     `$(TEXINDEX)' commands.  The actual command sequence contains
     many shell conditionals to avoid unnecessarily running TeX twice
     and to create the proper sorted index files.  `N.info' will be
     made from `N.texinfo' with the command `$(MAKEINFO)'.

RCS
     Any file `N' will be extracted if necessary from an RCS file
     named either `N,v' or `RCS/N,v'.  The precise command used is
     `$(CO) $(COFLAGS)'.  `N' will not be extracted from RCS if it
     already exists, even if the RCS file is newer.

SCCS
     Any file `N' will be extracted if necessary from an SCCS file
     named either `s.N' or `SCCS/s.N'.  The precise command used is
     `$(GET) $(GFLAGS)'.

     For the benefit of SCCS, a file `N' will be copied from `N.sh'
     and made executable (by everyone).  This is for shell scripts
     that are checked into SCCS.  Since RCS preserves the execution
     permission of a file, you don't need to use this feature with RCS.

     We recommend that you avoid the use of SCCS.  RCS is widely held
     to be superior, and is also free.  By choosing free software in
     place of comparable (or inferior) proprietary software, you
     support the free software movement.



File: make-info,  Node: Implicit Variables,  Next: Chained Rules,  Prev: Catalogue of Rules,  Up: Implicit

Variables Used by Implicit Rules
================================

The commands in built-in implicit rules make liberal use of certain
predefined variables.  You can alter these variables, either in the
makefile or with arguments to `make', to alter how the implicit rules
work without redefining the rules themselves.

For example, the command used to compile a C source file actually
says `$(CC) -c $(CFLAGS) $(CPPFLAGS)'.  The default values of the
variables used are `cc' and nothing, resulting in the command `cc
-c'.  By redefining `$(CC)' to `ncc', you could cause `ncc' to be
used for all C compilations performed by the implicit rule.  By
redefining `$(CFLAGS)' to be `-g', you could pass the `-g' option to
each compilation.  *All* implicit rules that do C compilation use
`$(CC)' to get the program name for the compiler and *all* include
`$(CFLAGS)' among the arguments given to the compiler.

The variables used in implicit rules fall into two classes: those
that are names of programs (like `CC') and those that contain
arguments for the programs (like `CFLAGS').  (The ``name of a
program'' may also contain some command arguments, but it must start
with an actual executable program name.)  If a variable value
contains more than one argument, separate them with spaces.

Here is a table of variables used as names of programs:

`AR'
     Archive-maintaing program; default `ar'.

`AS'
     Program for doing assembly; default `as'.

`CC'
     Program for compiling C programs; default `cc'.

`C++'
     Program for compiling C++ programs; default `g++'.

`CO'
     Program for extracting a file from RCS; default `co'.

`CPP'
     Program for running the C preprocessor, with results to standard
     output; default `$(CC) -E'.

`FC'
     Program for compiling or preprocessing Fortran, Ratfor, and EFL
     programs; default `f77'.

`GET'
     Program for extracting a file from SCCS; default `get'.

`LEX'
     Program to use to turn Lex grammars into C programs or Ratfor
     programs; default `lex'.

`PC'
     Program for compiling Pascal programs; default `pc'.

`FC'
`EC'
`RC'
     Programs for compiling Fortran, EFL, and Ratfor programs,
     respectively; these all default to `f77'.

`YACC'
     Program to use to turn Yacc grammars into C programs; default
     `yacc'.

`YACCR'
     Program to use to turn Yacc grammars into Ratfor programs;
     default `yacc -r'.

`YACCE'
     Program to use to turn Yacc grammars into EFL programs; default
     `yacc -e'.

`MAKEINFO'
     Program to make Info files from Texinfo source; default
     `makeinfo'.

`TEX'
     Program to make TeX DVI files from TeX or Texinfo source;
     default `tex'.

`TEXINDEX'
     The `texindex' program distributed with Emacs.  This is used in
     the process to make TeX DVI files from Texinfo source.

`WEAVE'
     Program to translate Web into TeX; default `weave'.

`CWEAVE'
     Program to translate C Web into TeX; default `cweave'.

`TANGLE'
     Program to translate Web into Pascal; default `tangle'.

`CTANGLE'
     Program to translate C Web into C; default `ctangle'.

`RM'
     Command to remove a file; default `rm -f'.

Here is a table of variables whose values are additional arguments
for the programs above.  The default values for all of these is the
empty string, unless otherwise noted.

`ARFLAGS'
     Flags to give the archive- maintaining program; default `rv'.

`ASFLAGS'
     Extra flags to give to the assembler (when explicitly invoked on
     a `.s' file).

`CFLAGS'
     Extra flags to give to the C compiler.

`C++FLAGS'
     Extra flags to give to the C++ compiler.

`COFLAGS'
     Extra flags to give to the RCS `co' program.

`CPPFLAGS'
     Extra flags to give to the C preprocessor and programs that use
     it (the C and Fortran compilers).

`EFLAGS'
     Extra flags to give to the Fortran compiler for EFL programs.

`FFLAGS'
     Extra flags to give to the Fortran compiler.

`GFLAGS'
     Extra flags to give to the SCCS `get' program.

`LDFLAGS'
     Extra flags to give to compilers when they are supposed to
     invoke the linker, `ld'.

`LFLAGS'
     Extra flags to give to Lex.

`PFLAGS'
     Extra flags to give to the Pascal compiler.

`RFLAGS'
     Extra flags to give to the Fortran compiler for Ratfor programs.

`YFLAGS'
     Extra flags to give to Yacc.



File: make-info,  Node: Chained Rules,  Next: Pattern Rules,  Prev: Implicit Variables,  Up: Implicit

Chains of Implicit Rules
========================

Sometimes a file can be made by a sequence of implicit rules.  For
example, a file `N.o' could be made from `N.y' by running first Yacc
and then `cc'.  Such a sequence is called a "chain".

If the file `N.c' exists, or is mentioned in the makefile, no special
searching is required: `make' finds that the object file can be made
by C compilation from `N.c'; later on, when considering how to make
`N.c', the rule for running Yacc will be used.  Ultimately both `N.c'
and `N.o' are updated.

However, even if `N.c' does not exist and is not mentioned, `make'
knows how to envision it as the missing link between `N.o' and `N.y'!
In this case, `N.c' is called an "intermediate file".  Once `make'
has decided to use the intermediate file, it is entered in the data
base as if it had been mentioned in the makefile, along with the
implicit rule that says how to create it.

Intermediate files are remade using their rules just like all other
files.  The difference is that the intermediate file is deleted when
`make' is finished.  Therefore, the intermediate file which did not
exist before `make' also does not exist after `make'.  The deletion
is reported to you by printing a `rm -f' command that shows what
`make' is doing.  (You can optionally define an implicit rule so as
to preserve certain intermediate files.  You can also list the target
pattern of an implicit rule (such as `%.o') as a dependency file of
the special target `.PRECIOUS' to preserve intermediate files whose
target patterns match that file's name.)

A chain can involve more than two implicit rules.  For example, it is
possible to make a file `foo' from `RCS/foo.y,v' by running RCS, Yacc
and `cc'.  Then both `foo.y' and `foo.c' are intermediate files that
are deleted at the end.

No single implicit rule can appear more than once in a chain.  This
means that `make' will not even consider such a ridiculous thing as
making `foo' from `foo.o.o' by running the linker twice.  This
constraint has the added benefit of preventing any infinite loop in
the search for an implicit rule chain.

There are some special implicit rules to optimize certain cases that
would otherwise by handled by rule chains.  For example, making `foo'
from `foo.c' could be handled by compiling and linking with separate
chained rules, using `foo.o' as an intermediate file.  But what
actually happens is that a special rule for this case does the
compilation and linking with a single `cc' command.  The optimized
rule is used in preference to the step-by-step chain because it comes
earlier in the ordering of rules.



File: make-info,  Node: Pattern Rules,  Next: Last Resort,  Prev: Chained Rules,  Up: Implicit

Defining and Redefining Pattern Rules
=====================================

You define an implicit rule by writing a "pattern rule".  A pattern
rule looks like an ordinary rule, except that its target contains the
character `%' (exactly one of them).  The target is considered a
pattern for matching file names; the `%' can match any nonempty
substring, while other characters match only themselves.  The
dependencies likewise use `%' to show how their names relate to the
target name.

Thus, a pattern rule `%.o : %.c' says how to make any file `STEM.o'
from another file `STEM.c'.

* Menu:

* Intro: Pattern Intro.        Basics of writing pattern rules.
* Examples: Pattern Examples.  Real examples of pattern rule definitions.

* Vars: Automatic.             The automatic variables enable the commands
                                in pattern rules to act on the right files.

* Matching: Pattern Match.     Details of how patterns match.

* Match-Anything Rules::       Precautions in defining a rules that can
                                match any target file whatever.

* Canceling Rules::            Overriding or canceling built-in rules.

* Last Resort::                How to define a last-resort rule
                                that applies to any target that no other
                                rule applies to.

* Suffix Rules::               The old-fashioned way to define implicit rules.

 

File: make-info,  Node: Pattern Intro,  Next: Pattern Examples,  Prev: Pattern Rules,  Up: Pattern Rules

Introduction to Pattern Rules
-----------------------------

You define an implicit rule by writing a "pattern rule".  A pattern
rule looks like an ordinary rule, except that its target contains the
character `%' (exactly one of them).  The target is considered a
pattern for matching file names; the `%' can match any nonempty
substring, while other characters match only themselves.

For example, `%.c' as a pattern matches any file name that ends in
`.c'.  `s.%.c' as a pattern matches any file name that starts with
`s.', ends in `.c' and is at least five characters long.  (There must
be at least one character to match the `%'.)  The substring that the
`%' matches is called the "stem".

`%' in a dependency of a pattern rule stands for the same stem that
was matched by the `%' in the target.  In order for the pattern rule
to apply, its target pattern must match the file name under
consideration, and its dependency patterns must name files that exist
or can be made.  These files become dependencies of the target.

Thus, a rule of the form

     %.o : %.c

would specify how to make any file `N.o', with another file `N.c' as
its dependency, provided that the other file exists or can be made.

There may also be dependencies that do not use `%'; such a dependency
attaches to every file made by this pattern rule.  These unvarying
dependencies are useful occasionally.

It is allowed for a pattern rule to have no dependencies that contain
`%' or to have no dependencies at all.  This is effectively a general
wildcard.  It provides a way to make any file that matches the target
pattern.

Pattern rules may have more than one target.  Unlike normal rules,
this does not act as many different rules with the same dependencies
and commands.  If a pattern rule has multiple targets, `make' knows
that the rule's commands are responsible for making all of the
targets.  The commands are executed only once to make all of the
targets.  When searching for a pattern rule to match a target, the
target patterns of a rule other than the one that matches the target
in need of a rule are incidental: `make' worries only about giving
commands and dependencies to the file presently in question. 
However, when this file's commands are run, the other targets are
marked as having been updated themselves.

The order in which pattern rules appear in the makefile is important
because the rules are considered in that order.  Of equally
applicable rules, the first one found is used.  The rules you write
take precedence over those that are built in.  Note, however, that a
rule whose dependencies actually exist or are mentioned always takes
priority over a rule with dependencies that must be made by chaining
other implicit rules.



File: make-info,  Node: Pattern Examples,  Next: Automatic,  Prev: Pattern Intro,  Up: Pattern Rules

Pattern Rule Examples
---------------------

Here are some examples of pattern rules actually predefined in
`make'.  First, the rule that compiles `.c' files into `.o' files:

     %.o : %.c
             $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@

defines a rule that can make any file `X.o' from `X.c'.  The command
uses the automatic variables `$@' and `$<' to substitute the names of
the target file and the source file in each case where the rule
applies (*note Automatic::.).

Here is a second built-in rule:

     % :: RCS/%,v
             $(CO) $(COFLAGS) $<

defines a rule that can make any file `X' whatever from a
corresponding file `X,v' in the subdirectory `RCS'.  Since the target
is `%', this rule will apply to any file whatever, provided the
appropriate dependency file exists.  The double colon makes the rule
"terminal", which means that its dependency may not be an
intermediate file (*note Match-Anything Rules::.).

This pattern rule has two targets:

     %.tab.c %.tab.h: %.y
             bison -d $<

This tells `make' that the command `bison -d X.y' will make both
`X.tab.c' and `X.tab.h'.  If the file `foo' depends on the files
`parse.tab.o' and `scan.o' and `scan.o' depends on `parse.tab.h',
when `parse.y' is changed, the command `bison -d parse.y' will be
executed only once, and the dependencies of both `parse.tab.o' and
`scan.o' will be satisfied.  (Presumably, `parse.tab.o' will be
recompiled from `parse.tab.c' and `scan.o' from `scan.c', and `foo'
will be linked from `parse.tab.o', `scan.o', and its other
dependencies, and it will execute happily ever after.)



File: make-info,  Node: Automatic,  Next: Pattern Match,  Prev: Pattern Examples,  Up: Pattern Rules

Automatic Variables
-------------------

Suppose you are writing a pattern rule to compile a `.c' file into a
`.o' file: how do you write the `cc' command so that it operates on
the right source file name?  You can't write the name in the command,
because the name is different each time the implicit rule is applied.

What you do is use a special feature of `make', the "automatic
variables".  These variables have values computed afresh for each
rule that is executed, based on the target and dependencies of the
rule.  In this example, you would use `$@' for the object file name
and `$<' for the source file name.

Here is a table of automatic variables:

`$@'
     The file name of the target of the rule.  If the target is an
     archive member, then `$@' is the name of the archive file.

`$%'
     The target member name, when the target is an archive member. 
     For example, if the target is `foo.a(bar.o)' then `$%' is
     `bar.o' and `$@' is `foo.a'.  `$%' is empty when the target is
     not an archive member.

`$<'
     The name of the first dependency.

`$?'
     The names of all the dependencies that are newer than the
     target, with spaces between them.

`$^'
     The names of all the dependencies, with spaces between them.

`$*'
     The stem with which an implicit rule matches (*note Pattern
     Match::.).  If the target is `dir/a.foo.b' and the target
     pattern is `a.%.b' then the stem is `dir/foo'.  The stem is
     useful for constructing names of related files.

     In an explicit rule, there is no stem; so `$*' cannot be
     determined in that way.  Instead, if the target name ends with a
     recognized suffix (*note Suffix Rules::.), `$*' is set to the
     target name minus the suffix.  For example, if the target name
     is `foo.c', then `$*' is set to `foo', since `.c' is a suffix.

     If the target name in an explicit rule does not end with a
     recognized suffix, `$*' is set to the empty string for that rule.

`$?' is useful even in explicit rules when you wish to operate on
only the dependencies that have changed.  For example, suppose that
an archive named `lib' is supposed to contain copies of several
object files.  This rule copies just the changed object files into
the archive:

     lib: foo.o bar.o lose.o win.o
             ar r lib $?

 Of the variables listed above, four have values that are single file
names, and two have values that are lists of file names.  These six
have variants that get just the file's directory name or just the
file name within the directory.  The variant variables' names are
formed by appending `D' or `F', respectively.  These variants are
semi-obsolete in GNU `make' since the functions `dir' and `notdir'
can be used to get an equivalent effect (*note Filename
Functions::.).  Here is a table of the variants:

`$(@D)'
     The directory part of the file name of the target.  If the value
     of `$@' is `dir/foo.o' then `$(@D)' is `dir/'.  This value is
     `./' if `$@' does not contain a slash.  `$(@D)' is equivalent to
     `$(dir $@)'.

`$(@F)'
     The file-within-directory part of the file name of the target. 
     If the value of `$@' is `dir/foo.o' then `$(@F)' is `foo.o'. 
     `$(@F)' is equivalent to `$(notdir $@)'.

`$(*D)'
`$(*F)'
     The directory part and the file-within-directory part of the
     stem; `dir/' and `foo' in this example.

`$(%D)'
`$(%F)'
     The directory part and the file-within-directory part of the
     target archive member name.  This makes sense only for archive
     member targets of the form `ARCHIVE(MEMBER)' and useful only
     when MEMBER may contain a directory name.  (*Note Archive
     Members::.)

`$(<D)'
`$(<F)'
     The directory part and the file-within-directory part of the
     first dependency.

`$(^D)'
`$(^F)'
     Lists of the directory parts and the file-within-directory parts
     of all dependencies.

`$(?D)'
`$(?F)'
     Lists of the directory parts and the file-within-directory parts
     of all dependencies that are out of date with respect to the
     target.

Note that we use a special stylistic convention when we talk about
these automatic variables; we write ``the value of `$<''', rather
than ``the variable `<''' as we would write for ordinary variables
such as `objects' and `CFLAGS'.  We think this convention looks more
natural in this special case.  Please don't assume it has a deep
significance; `$<' refers to the variable named `<' just as
`$(CFLAGS)' refers to the variable named `CFLAGS'.



