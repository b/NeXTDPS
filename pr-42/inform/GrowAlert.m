
/* Generated by the NeXT Interface Builder */
#import <syslog.h>

#import <appkit/Button.h>
#import <appkit/Application.h>
#import <appkit/Cell.h>
#import <appkit/Text.h>
#import <appkit/Window.h>
#import <appkit/Font.h>
#import "GrowAlert.h"

static char *remoteHost;

DPSTimedEntry errorTE;

DPSTimedEntryProc errorCheck( DPSTimedEntry, double, char * );

@implementation GrowAlert



+ new
{
    self = [super new];
    [NXApp loadNibSection: "PrinterAlert" owner: self];
    return self;
}

- setText: anObject { text = anObject; }
- setButton1: anObject { button1 = anObject; }
- setButton2: anObject { button2 = anObject; }
- setWindow: anObject
{ 
  window = anObject; 
  [window setDelegate: self];
  return self;
}

- window { return window; }
- text { return text; }

- ok:sender
{
  [window orderOut: self];
  [NXApp stopModal];
  return self;
}

- cancel:sender
{
  DPSRemoveTimedEntry( errorTE );
  [window orderOut: self];
  if( !npd_remove() )
    NXRunAlertPanel( 0, "Couldn't remove print request", 0, 0, 0 );
  [NXApp stopModal];
  return self;
}

    

PrinterAlert( char *host, char *s, char *b1, char *b2, int flag )
{
  register char *sp = s;
  register int l = strlen( s );
  GrowAlert *a = [GrowAlert new];
  NXRect f1, f2;

  if( flag ){
    errorTE = DPSAddTimedEntry(4.0,(DPSTimedEntryProc)errorCheck,(void *)host,NX_MODALRESPTHRESHOLD);
  }
  
  remoteHost = host;
  
  [a->text setStringValue:s];  
    
  if( !calc( a, s ) )
    return( 0 );

  if( b1 )
    [a->button1 setTitle: b1];
  else 
    [a->button1 setTitle: "OK"];
    
  if( b2 )
    [a->button2 setTitle: b2];
  else{
    [a->button2 removeFromSuperview];
    [a->button1 getFrame: &f1];
    [a->button1 sizeToFit];
    [a->button1 getFrame: &f2];
    [a->button1 moveBy: (f1.size.width - f2.size.width)  : 0];
  }
    
  [a->window display];
  [a->window orderFront: a];
  
  [NXApp runModalFor: a->window];
  return 0;
}


calc( id panel, char *string )
{
#define MAXWIDTH (500.0)

  NXCoord height, fheight, ascend, descend;
  NXRect b;
  NXSize newSize;
  float width = 0.0, twidth = 0.0;
  int lines = 0;
  id f;
  char *cp, *sp;
  int incWidth = 0, incHeight = 0;

  f = [[panel text] font];
  if( !f )
    return( 0 );

  NXTextFontInfo(f, &ascend, &descend, &fheight);

  /* Count lines. */
  cp = string;
  while( *cp )
    if( *cp++ == '\n' )
      lines++;
  if( (lines == 0 && cp != string) || *(cp-1) != '\n' )
    lines++;
  
  height = (fheight*(float)lines);
  
  /* Get length of longest line. */
  sp = cp = string;
  twidth = [f getWidthOf: sp] + 58.0;
  while( *cp ){
    if( *cp == '\n' ){
      *cp = 0;
      twidth = [f getWidthOf: sp] + 58.0;
      if( twidth > width )
	width = twidth;
      twidth = 0.0;
      *cp++ = '\n';
      sp = cp;
    }
    else{
      cp++;
    }
  }

  if( twidth > width )
    width = twidth;
  if (width > MAXWIDTH)
      width = MAXWIDTH;

  [[panel text] getBounds: &b];
  if( width > b.size.width )
    incWidth = width - b.size.width;
  b.size.width += incWidth;
  [[[panel text] cell] calcCellSize:&newSize inRect:&b];
  height = newSize.height;
  if( height > b.size.height )
    incHeight = height - b.size.height;

  if( incWidth || incHeight ){
    [[[panel window] contentView] getFrame: &b];
    [[panel window] sizeWindow: b.size.width+incWidth:b.size.height+incHeight];
  }

  return( 1 );
}

#include "npd.h"

npd_remove()
{
  port_t npd_port;
  npd_con_msg *con_msg;
  msg_return_t ret_code;

  npd_port = FindPort( remoteHost, NPD_PUBLIC_PORT );
  if( !npd_port )
    return( 0 );

  con_msg = (npd_con_msg *)malloc( sizeof(npd_con_msg) );
  bzero( con_msg, sizeof(con_msg) );
  con_msg->head.msg_remote_port = npd_port;
  con_msg->head.msg_local_port = PORT_NULL;
  con_msg->head.msg_size = sizeof( npd_con_msg );
  con_msg->head.msg_id = NPD_REMOVE;
  con_msg->head.msg_type = MSG_TYPE_NORMAL;
  con_msg->head.msg_simple = 1;

  if( (ret_code = msg_send( con_msg, SEND_TIMEOUT, (msg_timeout_t)15000)) != SEND_SUCCESS ){
    syslog( LOG_ERR, "failed to send remove message to npd, %d", ret_code );
  }
  
  FreePort( npd_port );
  free( con_msg );
  
  return( ret_code == SEND_SUCCESS );
}

DPSTimedEntryProc 
errorCheck( DPSTimedEntry t, double now, char *host )
{
  int r;
  int firstAlert = 1;

  if( npd_printer_status( host ) == 0 ){
    DPSRemoveTimedEntry( errorTE );
    [NXApp terminate: 0];
  }
}

npd_printer_status( char *host )
{
  port_t npd_port, reply_port;
  npd_con_msg *con_msg;
  msg_return_t ret_code;
  msg_header_t *rec_msg;
  int msg_id;

  npd_port = FindPort( host, NPD_PUBLIC_PORT );
  if( !npd_port )
    return( 1 );

  reply_port = CreatePort( 0 );
  con_msg = (npd_con_msg *)malloc( sizeof(npd_con_msg) );
  bzero( con_msg, sizeof(con_msg) );
  con_msg->head.msg_remote_port = npd_port;
  con_msg->head.msg_local_port = reply_port;
  con_msg->head.msg_size = sizeof( npd_con_msg );
  con_msg->head.msg_id = NPD_PRINTER_STATUS;
  con_msg->head.msg_type = MSG_TYPE_NORMAL;
  con_msg->head.msg_simple = 1;
  if( (ret_code = msg_send( con_msg, SEND_TIMEOUT, (msg_timeout_t)(3000) )) != SEND_SUCCESS ){
    FreePort( reply_port );
    FreePort( npd_port );
    free( con_msg );
    syslog( LOG_ERR, "couldn't send status request to npd, %d\n", ret_code );
    return( 1 );
  }

  rec_msg = (msg_header_t *)malloc( sizeof( msg_header_t ) );
  rec_msg->msg_local_port = reply_port;
  rec_msg->msg_size = sizeof( msg_header_t );
  if( (ret_code = msg_receive( rec_msg, RCV_TIMEOUT, (msg_timeout_t)(3000))) != RCV_SUCCESS ){
    syslog( LOG_ERR, "no reply to status request from npd, %d\n", ret_code );
    FreePort( reply_port );
    FreePort( npd_port );
    free( con_msg );
    free( rec_msg );
    return( 1 );
  }
  FreePort( reply_port );
  FreePort( npd_port );
  free( con_msg );
  msg_id = rec_msg->msg_id;	/* this avoids a reference to a freed */
  				/* pointer in the following return statement */
  free( rec_msg );

  return( msg_id );
}

@end

